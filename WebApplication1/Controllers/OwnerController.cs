//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"

namespace MyNamespace
{
    using Microsoft.AspNetCore.Mvc;
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public interface IController
    {

        /// <summary>
        /// Check the status of Harbor components
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <returns>The health status of Harbor components</returns>

        System.Threading.Tasks.Task<OverallHealthStatus> GetHealthAsync(string x_Request_Id);

        /// <summary>
        /// Search for projects, repositories and helm charts
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="q">Search parameter for project and repository name.</param>

        /// <returns>An array of search results</returns>

        System.Threading.Tasks.Task<Search> SearchAsync(string x_Request_Id, string q);

        /// <summary>
        /// Get the statistic information about the projects and repositories
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <returns>The statistic information</returns>

        System.Threading.Tasks.Task<Statistic> GetStatisticAsync(string x_Request_Id);

        /// <summary>
        /// Ping available ldap service.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="ldapconf">ldap configuration. support input ldap service configuration. If it is a empty request, will load current configuration from the system.</param>

        /// <returns>Ping ldap service successfully.</returns>

        System.Threading.Tasks.Task<LdapPingResult> PingLdapAsync(string x_Request_Id, LdapConf ldapconf);

        /// <summary>
        /// Search available ldap users.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="username">Registered user ID</param>

        /// <returns>Search ldap users successfully.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<LdapUser>> SearchLdapUserAsync(string x_Request_Id, string username);

        /// <summary>
        /// Import selected available ldap users.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="uid_list">The uid listed for importing. This list will check users validity of ldap service based on configuration from the system.</param>

        /// <returns>Add ldap users successfully.</returns>

        System.Threading.Tasks.Task ImportLdapUserAsync(string x_Request_Id, LdapImportUsers uid_list);

        /// <summary>
        /// Search available ldap groups.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="groupname">Ldap group name</param>

        /// <param name="groupdn">The LDAP group DN</param>

        /// <returns>Search ldap group successfully.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<UserGroup>> SearchLdapGroupAsync(string x_Request_Id, string groupname, string groupdn);

        /// <summary>
        /// Get internal configurations.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <returns>Get system configurations successfully. The response body is a map.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, InternalConfigurationValue>> GetInternalconfigAsync(string x_Request_Id);

        /// <summary>
        /// Get system configurations.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <returns>Get system configurations successfully. The response body is a map.</returns>

        System.Threading.Tasks.Task<ConfigurationsResponse> GetConfigurationsAsync(string x_Request_Id);

        /// <summary>
        /// Modify system configurations.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="configurations">The configuration map can contain a subset of the attributes of the schema, which are to be updated.</param>

        /// <returns>Modify system configurations successfully.</returns>

        System.Threading.Tasks.Task UpdateConfigurationsAsync(string x_Request_Id, Configurations configurations);

        /// <summary>
        /// List projects
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <param name="name">The name of project.</param>

        /// <param name="@public">The project is public or private.</param>

        /// <param name="owner">The name of project owner.</param>

        /// <param name="with_detail">Bool value indicating whether return detailed information of the project</param>

        /// <returns>Return all matched projects.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Project>> ListProjectsAsync(string x_Request_Id, string q, long page, long page_size, string sort, string name, bool? @public, string owner, bool with_detail);

        /// <summary>
        /// Check if the project name user provided already exists.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">Project name for checking exists.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task HeadProjectAsync(string x_Request_Id, string project_name);

        /// <summary>
        /// Create a new project.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Resource_Name_In_Location">The flag to indicate whether to return the name of the resource in Location. When X-Resource-Name-In-Location is true, the Location will return the name of the resource.</param>

        /// <param name="project">New created project.</param>

        /// <returns>Created</returns>

        System.Threading.Tasks.Task CreateProjectAsync(string x_Request_Id, bool x_Resource_Name_In_Location, ProjectReq project);

        /// <summary>
        /// Return specific project detail information
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <returns>Return matched project information.</returns>

        System.Threading.Tasks.Task<Project> GetProjectAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id);

        /// <summary>
        /// Update properties for a selected project.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="project">Updates of project.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task UpdateProjectAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, ProjectReq project);

        /// <summary>
        /// Delete project by projectID
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task DeleteProjectAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id);

        /// <summary>
        /// Get the deletable status of the project
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <returns>Return deletable status of the project.</returns>

        System.Threading.Tasks.Task<ProjectDeletable> GetProjectDeletableAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id);

        /// <summary>
        /// Get summary of the project.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <returns>Get summary of the project successfully.</returns>

        System.Threading.Tasks.Task<ProjectSummary> GetProjectSummaryAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id);

        /// <summary>
        /// Get all project member information
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <param name="entityname">The entity name to search.</param>

        /// <returns>Get project members successfully.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ProjectMemberEntity>> ListProjectMembersAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, long page, long page_size, string entityname);

        /// <summary>
        /// Create project member
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>


        /// <returns>Project member created successfully.</returns>

        System.Threading.Tasks.Task CreateProjectMemberAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, ProjectMember project_member);

        /// <summary>
        /// Get the project member information
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="mid">The member ID</param>

        /// <returns>Project member retrieved successfully.</returns>

        System.Threading.Tasks.Task<ProjectMemberEntity> GetProjectMemberAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, long mid);

        /// <summary>
        /// Update project member
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="mid">Member ID.</param>


        /// <returns>Success</returns>

        System.Threading.Tasks.Task UpdateProjectMemberAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, long mid, RoleRequest role);

        /// <summary>
        /// Delete project member
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="mid">Member ID.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task DeleteProjectMemberAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, long mid);

        /// <summary>
        /// Get the metadata of the specific project
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, string>> ListProjectMetadatasAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id);

        /// <summary>
        /// Add metadata for the specific project
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>


        /// <returns>Success</returns>

        System.Threading.Tasks.Task AddProjectMetadatasAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, System.Collections.Generic.IDictionary<string, string> metadata);

        /// <summary>
        /// Get the specific metadata of the specific project
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="meta_name">The name of metadata.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, string>> GetProjectMetadataAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, string meta_name);

        /// <summary>
        /// Update the specific metadata for the specific project
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="meta_name">The name of metadata.</param>


        /// <returns>Success</returns>

        System.Threading.Tasks.Task UpdateProjectMetadataAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, string meta_name, System.Collections.Generic.IDictionary<string, string> metadata);

        /// <summary>
        /// Delete the specific metadata for the specific project
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="meta_name">The name of metadata.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task DeleteProjectMetadataAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, string meta_name);

        /// <summary>
        /// List all authorized repositories
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Repository>> ListAllRepositoriesAsync(string x_Request_Id, string q, string sort, long page, long page_size);

        /// <summary>
        /// List repositories
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Repository>> ListRepositoriesAsync(string x_Request_Id, string project_name, string q, string sort, long page, long page_size);

        /// <summary>
        /// Get repository
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<Repository> GetRepositoryAsync(string x_Request_Id, string project_name, string repository_name);

        /// <summary>
        /// Update repository
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>

        /// <param name="repository">The JSON object of repository.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task UpdateRepositoryAsync(string x_Request_Id, string project_name, string repository_name, Repository repository);

        /// <summary>
        /// Delete repository
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task DeleteRepositoryAsync(string x_Request_Id, string project_name, string repository_name);

        /// <summary>
        /// List artifacts
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <param name="x_Accept_Vulnerabilities">A comma-separated lists of MIME types for the scan report or scan summary. The first mime type will be used when the report found for it.
        /// <br/>Currently the mime type supports 'application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0' and 'application/vnd.security.vulnerability.report; version=1.1'</param>

        /// <param name="with_tag">Specify whether the tags are included inside the returning artifacts</param>

        /// <param name="with_label">Specify whether the labels are included inside the returning artifacts</param>

        /// <param name="with_scan_overview">Specify whether the scan overview is included inside the returning artifacts</param>

        /// <param name="with_signature">Specify whether the signature is included inside the tags of the returning artifacts. Only works when setting "with_tag=true"</param>

        /// <param name="with_immutable_status">Specify whether the immutable status is included inside the tags of the returning artifacts. Only works when setting "with_immutable_status=true"</param>

        /// <param name="with_accessory">Specify whether the accessories are included of the returning artifacts. Only works when setting "with_accessory=true"</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Artifact>> ListArtifactsAsync(string x_Request_Id, string project_name, string repository_name, string q, string sort, long page, long page_size, string x_Accept_Vulnerabilities, bool with_tag, bool with_label, bool with_scan_overview, bool with_signature, bool with_immutable_status, bool with_accessory);

        /// <summary>
        /// Copy artifact
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>

        /// <param name="from">The artifact from which the new artifact is copied from, the format should be "project/repository:tag" or "project/repository@digest".</param>

        /// <returns>Created</returns>

        System.Threading.Tasks.Task CopyArtifactAsync(string x_Request_Id, string project_name, string repository_name, string from);

        /// <summary>
        /// Get the specific artifact
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>

        /// <param name="reference">The reference of the artifact, can be digest or tag</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <param name="x_Accept_Vulnerabilities">A comma-separated lists of MIME types for the scan report or scan summary. The first mime type will be used when the report found for it.
        /// <br/>Currently the mime type supports 'application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0' and 'application/vnd.security.vulnerability.report; version=1.1'</param>

        /// <param name="with_tag">Specify whether the tags are inclued inside the returning artifacts</param>

        /// <param name="with_label">Specify whether the labels are inclued inside the returning artifacts</param>

        /// <param name="with_scan_overview">Specify whether the scan overview is inclued inside the returning artifacts</param>

        /// <param name="with_accessory">Specify whether the accessories are included of the returning artifacts.</param>

        /// <param name="with_signature">Specify whether the signature is inclued inside the returning artifacts</param>

        /// <param name="with_immutable_status">Specify whether the immutable status is inclued inside the tags of the returning artifacts.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<Artifact> GetArtifactAsync(string x_Request_Id, string project_name, string repository_name, string reference, long page, long page_size, string x_Accept_Vulnerabilities, bool with_tag, bool with_label, bool with_scan_overview, bool with_accessory, bool with_signature, bool with_immutable_status);

        /// <summary>
        /// Delete the specific artifact
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>

        /// <param name="reference">The reference of the artifact, can be digest or tag</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task DeleteArtifactAsync(string x_Request_Id, string project_name, string repository_name, string reference);

        /// <summary>
        /// Scan the artifact
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>

        /// <param name="reference">The reference of the artifact, can be digest or tag</param>

        /// <returns>Accepted</returns>

        System.Threading.Tasks.Task ScanArtifactAsync(string x_Request_Id, string project_name, string repository_name, string reference);

        /// <summary>
        /// Cancelling a scan job for a particular artifact
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>

        /// <param name="reference">The reference of the artifact, can be digest or tag</param>

        /// <returns>Accepted</returns>

        System.Threading.Tasks.Task StopScanArtifactAsync(string x_Request_Id, string project_name, string repository_name, string reference);

        /// <summary>
        /// Get the log of the scan report
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>

        /// <param name="reference">The reference of the artifact, can be digest or tag</param>

        /// <param name="report_id">The report id to get the log</param>

        /// <returns>Successfully get scan log file</returns>

        System.Threading.Tasks.Task<string> GetReportLogAsync(string x_Request_Id, string project_name, string repository_name, string reference, string report_id);

        /// <summary>
        /// Create tag
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>

        /// <param name="reference">The reference of the artifact, can be digest or tag</param>

        /// <param name="tag">The JSON object of tag.</param>

        /// <returns>Created</returns>

        System.Threading.Tasks.Task CreateTagAsync(string x_Request_Id, string project_name, string repository_name, string reference, Tag tag);

        /// <summary>
        /// List tags
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>

        /// <param name="reference">The reference of the artifact, can be digest or tag</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <param name="with_signature">Specify whether the signature is included inside the returning tags</param>

        /// <param name="with_immutable_status">Specify whether the immutable status is included inside the returning tags</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Tag>> ListTagsAsync(string x_Request_Id, string project_name, string repository_name, string reference, string q, string sort, long page, long page_size, bool with_signature, bool with_immutable_status);

        /// <summary>
        /// Delete tag
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>

        /// <param name="reference">The reference of the artifact, can be digest or tag</param>

        /// <param name="tag_name">The name of the tag</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task DeleteTagAsync(string x_Request_Id, string project_name, string repository_name, string reference, string tag_name);

        /// <summary>
        /// List accessories
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>

        /// <param name="reference">The reference of the artifact, can be digest or tag</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Accessory>> ListAccessoriesAsync(string x_Request_Id, string project_name, string repository_name, string reference, string q, string sort, long page, long page_size);

        /// <summary>
        /// Get the vulnerabilities addition of the specific artifact
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>

        /// <param name="reference">The reference of the artifact, can be digest or tag</param>

        /// <param name="x_Accept_Vulnerabilities">A comma-separated lists of MIME types for the scan report or scan summary. The first mime type will be used when the report found for it.
        /// <br/>Currently the mime type supports 'application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0' and 'application/vnd.security.vulnerability.report; version=1.1'</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<string> GetVulnerabilitiesAdditionAsync(string x_Request_Id, string project_name, string repository_name, string reference, string x_Accept_Vulnerabilities);

        /// <summary>
        /// Get the addition of the specific artifact
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>

        /// <param name="reference">The reference of the artifact, can be digest or tag</param>

        /// <param name="addition">The type of addition.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<string> GetAdditionAsync(string x_Request_Id, string project_name, string repository_name, string reference, Addition addition);

        /// <summary>
        /// Add label to artifact
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>

        /// <param name="reference">The reference of the artifact, can be digest or tag</param>

        /// <param name="label">The label that added to the artifact. Only the ID property is needed.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task AddLabelAsync(string x_Request_Id, string project_name, string repository_name, string reference, Label label);

        /// <summary>
        /// Remove label from artifact
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>

        /// <param name="reference">The reference of the artifact, can be digest or tag</param>

        /// <param name="label_id">The ID of the label that removed from the artifact.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task RemoveLabelAsync(string x_Request_Id, string project_name, string repository_name, string reference, long label_id);

        /// <summary>
        /// Get project level scanner
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <returns>The details of the scanner registration.</returns>

        System.Threading.Tasks.Task<ScannerRegistration> GetScannerOfProjectAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id);

        /// <summary>
        /// Configure scanner for the specified project
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>


        /// <returns>Success</returns>

        System.Threading.Tasks.Task SetScannerOfProjectAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, ProjectScanner payload);

        /// <summary>
        /// Get scanner registration candidates for configurating project level scanner
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <returns>A list of scanner registrations.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ScannerRegistration>> ListScannerCandidatesOfProjectAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, string q, string sort, long page, long page_size);

        /// <summary>
        /// Get recent logs of the projects which the user is a member of
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<AuditLog>> ListAuditLogsAsync(string x_Request_Id, string q, string sort, long page, long page_size);

        /// <summary>
        /// Get recent logs of the projects
        /// </summary>

        /// <param name="project_name">The name of the project</param>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<AuditLog>> GetLogsAsync(string project_name, string x_Request_Id, string q, string sort, long page, long page_size);

        /// <summary>
        /// List P2P providers
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Metadata>> ListProvidersAsync(string x_Request_Id);

        /// <summary>
        /// Ping status of a instance.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="instance">The JSON object of instance.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task PingInstancesAsync(string x_Request_Id, Instance instance);

        /// <summary>
        /// List P2P provider instances
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Instance>> ListInstancesAsync(string x_Request_Id, long page, long page_size, string q, string sort);

        /// <summary>
        /// Create p2p provider instances
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="instance">The JSON object of instance.</param>

        /// <returns>Created</returns>

        System.Threading.Tasks.Task CreateInstanceAsync(string x_Request_Id, Instance instance);

        /// <summary>
        /// Get a P2P provider instance
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="preheat_instance_name">Instance Name</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<Instance> GetInstanceAsync(string x_Request_Id, string preheat_instance_name);

        /// <summary>
        /// Delete the specified P2P provider instance
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="preheat_instance_name">Instance Name</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task DeleteInstanceAsync(string x_Request_Id, string preheat_instance_name);

        /// <summary>
        /// Update the specified P2P provider instance
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="preheat_instance_name">Instance Name</param>

        /// <param name="instance">The instance to update</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task UpdateInstanceAsync(string x_Request_Id, string preheat_instance_name, Instance instance);

        /// <summary>
        /// Create a preheat policy under a project
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="policy">The policy schema info</param>

        /// <returns>Created</returns>

        System.Threading.Tasks.Task CreatePolicyAsync(string x_Request_Id, string project_name, PreheatPolicy policy);

        /// <summary>
        /// List preheat policies
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <returns>List preheat policies success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<PreheatPolicy>> ListPoliciesAsync(string x_Request_Id, string project_name, long page, long page_size, string q, string sort);

        /// <summary>
        /// Get a preheat policy
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="preheat_policy_name">Preheat Policy Name</param>

        /// <returns>Get a preheat policy success</returns>

        System.Threading.Tasks.Task<PreheatPolicy> GetPolicyAsync(string x_Request_Id, string project_name, string preheat_policy_name);

        /// <summary>
        /// Update preheat policy
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="preheat_policy_name">Preheat Policy Name</param>

        /// <param name="policy">The policy schema info</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task UpdatePolicyAsync(string x_Request_Id, string project_name, string preheat_policy_name, PreheatPolicy policy);

        /// <summary>
        /// Manual preheat
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="preheat_policy_name">Preheat Policy Name</param>

        /// <param name="policy">The policy schema info</param>

        /// <returns>Created</returns>

        System.Threading.Tasks.Task ManualPreheatAsync(string x_Request_Id, string project_name, string preheat_policy_name, PreheatPolicy policy);

        /// <summary>
        /// Delete a preheat policy
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="preheat_policy_name">Preheat Policy Name</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task DeletePolicyAsync(string x_Request_Id, string project_name, string preheat_policy_name);

        /// <summary>
        /// List executions for the given policy
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="preheat_policy_name">Preheat Policy Name</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <returns>List executions success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Execution>> ListExecutionsAsync(string x_Request_Id, string project_name, string preheat_policy_name, long page, long page_size, string q, string sort);

        /// <summary>
        /// Get a execution detail by id
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="preheat_policy_name">Preheat Policy Name</param>

        /// <param name="execution_id">Execution ID</param>

        /// <returns>Get execution success</returns>

        System.Threading.Tasks.Task<Execution> GetExecutionAsync(string x_Request_Id, string project_name, string preheat_policy_name, int execution_id);

        /// <summary>
        /// Stop a execution
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="preheat_policy_name">Preheat Policy Name</param>

        /// <param name="execution_id">Execution ID</param>

        /// <param name="execution">The data of execution</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task StopExecutionAsync(string x_Request_Id, string project_name, string preheat_policy_name, int execution_id, Execution execution);

        /// <summary>
        /// List all the related tasks for the given execution
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="preheat_policy_name">Preheat Policy Name</param>

        /// <param name="execution_id">Execution ID</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <returns>List tasks success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Task>> ListTasksAsync(string x_Request_Id, string project_name, string preheat_policy_name, int execution_id, long page, long page_size, string q, string sort);

        /// <summary>
        /// Get the log text stream of the specified task for the given execution
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <param name="preheat_policy_name">Preheat Policy Name</param>

        /// <param name="execution_id">Execution ID</param>

        /// <param name="task_id">Task ID</param>

        /// <returns>Get log success</returns>

        System.Threading.Tasks.Task<string> GetPreheatLogAsync(string x_Request_Id, string project_name, string preheat_policy_name, int execution_id, int task_id);

        /// <summary>
        /// Get all providers at project level
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="project_name">The name of the project</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ProviderUnderProject>> ListProvidersUnderProjectAsync(string x_Request_Id, string project_name);

        /// <summary>
        /// Get all robot accounts of specified project
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Robot>> ListRobotV1Async(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, long page, long page_size, string q, string sort);

        /// <summary>
        /// Create a robot account
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="robot">The JSON object of a robot account.</param>

        /// <returns>Created</returns>

        System.Threading.Tasks.Task<RobotCreated> CreateRobotV1Async(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, RobotCreateV1 robot);

        /// <summary>
        /// Get a robot account
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="robot_id">Robot ID</param>

        /// <returns>Return matched robot information.</returns>

        System.Threading.Tasks.Task<Robot> GetRobotByIDV1Async(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, int robot_id);

        /// <summary>
        /// Update status of robot account.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="robot_id">Robot ID</param>

        /// <param name="robot">The JSON object of a robot account.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task UpdateRobotV1Async(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, int robot_id, Robot robot);

        /// <summary>
        /// Delete a robot account
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="robot_id">Robot ID</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task DeleteRobotV1Async(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, int robot_id);

        /// <summary>
        /// List all immutable tag rules of current project
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ImmutableRule>> ListImmuRulesAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, long page, long page_size, string q, string sort);

        /// <summary>
        /// Add an immutable tag rule to current project
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>


        /// <returns>Created</returns>

        System.Threading.Tasks.Task CreateImmuRuleAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, ImmutableRule immutableRule);

        /// <summary>
        /// Update the immutable tag rule or enable or disable the rule
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="immutable_rule_id">The ID of the immutable rule</param>


        /// <returns>Success</returns>

        System.Threading.Tasks.Task UpdateImmuRuleAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, long immutable_rule_id, ImmutableRule immutableRule);

        /// <summary>
        /// Delete the immutable tag rule.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="immutable_rule_id">The ID of the immutable rule</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task DeleteImmuRuleAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, long immutable_rule_id);

        /// <summary>
        /// List project webhook policies.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<WebhookPolicy>> ListWebhookPoliciesOfProjectAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, string sort, string q, long page, long page_size);

        /// <summary>
        /// Create project webhook policy.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="policy">Properties "targets" and "event_types" needed.</param>

        /// <returns>Project webhook policy create successfully.</returns>

        System.Threading.Tasks.Task CreateWebhookPolicyOfProjectAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, WebhookPolicy policy);

        /// <summary>
        /// Get project webhook policy
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="webhook_policy_id">The ID of the webhook policy</param>

        /// <returns>Get webhook policy successfully.</returns>

        System.Threading.Tasks.Task<WebhookPolicy> GetWebhookPolicyOfProjectAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, long webhook_policy_id);

        /// <summary>
        /// Update webhook policy of a project.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="webhook_policy_id">The ID of the webhook policy</param>

        /// <param name="policy">All properties needed except "id", "project_id", "creation_time", "update_time".</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task UpdateWebhookPolicyOfProjectAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, long webhook_policy_id, WebhookPolicy policy);

        /// <summary>
        /// Delete webhook policy of a project
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="webhook_policy_id">The ID of the webhook policy</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task DeleteWebhookPolicyOfProjectAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, long webhook_policy_id);

        /// <summary>
        /// Get project webhook policy last trigger info
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <returns>Test webhook connection successfully.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<WebhookLastTrigger>> LastTriggerAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id);

        /// <summary>
        /// List project webhook jobs
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <param name="policy_id">The policy ID.</param>

        /// <param name="status">The status of webhook job.</param>

        /// <returns>List project webhook jobs successfully.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<WebhookJob>> ListWebhookJobsAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id, string q, string sort, long page, long page_size, long policy_id, System.Collections.Generic.IEnumerable<string> status);

        /// <summary>
        /// Get supported event types and notify types.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>

        /// <param name="project_name_or_id">The name or id of the project</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<SupportedWebhookEventTypes> GetSupportedEventTypesAsync(string x_Request_Id, bool x_Is_Resource_Name, string project_name_or_id);

        /// <summary>
        /// Get all user groups information
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <param name="ldap_group_dn">search with ldap group DN</param>

        /// <param name="group_name">group name need to search, fuzzy matches</param>

        /// <returns>Get user group successfully.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<UserGroup>> ListUserGroupsAsync(string x_Request_Id, long page, long page_size, string ldap_group_dn, string group_name);

        /// <summary>
        /// Create user group
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>


        /// <returns>User group created successfully.</returns>

        System.Threading.Tasks.Task CreateUserGroupAsync(string x_Request_Id, UserGroup usergroup);

        /// <summary>
        /// Search groups by groupname
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <param name="groupname">Group name for filtering results.</param>

        /// <returns>Search groups successfully.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<UserGroupSearchItem>> SearchUserGroupsAsync(string x_Request_Id, long page, long page_size, string groupname);

        /// <summary>
        /// Get user group information
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="group_id">Group ID</param>

        /// <returns>User group get successfully.</returns>

        System.Threading.Tasks.Task<UserGroup> GetUserGroupAsync(string x_Request_Id, long group_id);

        /// <summary>
        /// Update group information
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="group_id">Group ID</param>


        /// <returns>Success</returns>

        System.Threading.Tasks.Task UpdateUserGroupAsync(string x_Request_Id, long group_id, UserGroup usergroup);

        /// <summary>
        /// Delete user group
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>


        /// <returns>Success</returns>

        System.Threading.Tasks.Task DeleteUserGroupAsync(string x_Request_Id, int group_id);

        /// <summary>
        /// Get artifact icon
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="digest">The digest of the resource</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<Icon> GetIconAsync(string x_Request_Id, string digest);

        /// <summary>
        /// Get robot account
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Robot>> ListRobotAsync(string x_Request_Id, string q, string sort, long page, long page_size);

        /// <summary>
        /// Create a robot account
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="robot">The JSON object of a robot account.</param>

        /// <returns>Created</returns>

        System.Threading.Tasks.Task<RobotCreated> CreateRobotAsync(string x_Request_Id, RobotCreate robot);

        /// <summary>
        /// List quotas
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <param name="reference">The reference type of quota.</param>

        /// <param name="reference_id">The reference id of quota.</param>

        /// <param name="sort">Sort method, valid values include:
        /// <br/>'hard.resource_name', '-hard.resource_name', 'used.resource_name', '-used.resource_name'.
        /// <br/>Here '-' stands for descending order, resource_name should be the real resource name of the quota.</param>

        /// <returns>Successfully retrieved the quotas.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Quota>> ListQuotasAsync(string x_Request_Id, long page, long page_size, string reference, string reference_id, string sort);

        /// <summary>
        /// Get the specified quota
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="id">Quota ID</param>

        /// <returns>Successfully retrieved the quota.</returns>

        System.Threading.Tasks.Task<Quota> GetQuotaAsync(string x_Request_Id, int id);

        /// <summary>
        /// Update the specified quota
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="id">Quota ID</param>

        /// <param name="hard">The new hard limits for the quota</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task UpdateQuotaAsync(string x_Request_Id, int id, QuotaUpdateReq hard);

        /// <summary>
        /// Get a robot account
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="robot_id">Robot ID</param>

        /// <returns>Return matched robot information.</returns>

        System.Threading.Tasks.Task<Robot> GetRobotByIDAsync(string x_Request_Id, int robot_id);

        /// <summary>
        /// Update a robot account
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="robot_id">Robot ID</param>

        /// <param name="robot">The JSON object of a robot account.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task UpdateRobotAsync(string x_Request_Id, int robot_id, Robot robot);

        /// <summary>
        /// Refresh the robot secret
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="robot_id">Robot ID</param>

        /// <param name="robotSec">The JSON object of a robot account.</param>

        /// <returns>Return refreshed robot sec.</returns>

        System.Threading.Tasks.Task<RobotSec> RefreshSecAsync(string x_Request_Id, int robot_id, RobotSec robotSec);

        /// <summary>
        /// Delete a robot account
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="robot_id">Robot ID</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task DeleteRobotAsync(string x_Request_Id, int robot_id);

        /// <summary>
        /// List replication policies
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <param name="name">Deprecated, use "query" instead. The policy name.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ReplicationPolicy>> ListReplicationPoliciesAsync(string x_Request_Id, string q, string sort, long page, long page_size, string name);

        /// <summary>
        /// Create a replication policy
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="policy">The replication policy</param>

        /// <returns>Created</returns>

        System.Threading.Tasks.Task CreateReplicationPolicyAsync(string x_Request_Id, ReplicationPolicy policy);

        /// <summary>
        /// Get the specific replication policy
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="id">Policy ID</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<ReplicationPolicy> GetReplicationPolicyAsync(string x_Request_Id, long id);

        /// <summary>
        /// Delete the specific replication policy
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="id">Replication policy ID</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task DeleteReplicationPolicyAsync(string x_Request_Id, long id);

        /// <summary>
        /// Update the replication policy
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="id">The policy ID</param>

        /// <param name="policy">The replication policy</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task UpdateReplicationPolicyAsync(string x_Request_Id, long id, ReplicationPolicy policy);

        /// <summary>
        /// List replication executions
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <param name="policy_id">The ID of the policy that the executions belong to.</param>

        /// <param name="status">The execution status.</param>

        /// <param name="trigger">The trigger mode.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ReplicationExecution>> ListReplicationExecutionsAsync(string x_Request_Id, string sort, long page, long page_size, int? policy_id, string status, string trigger);

        /// <summary>
        /// Start one replication execution
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="execution">The ID of policy that the execution belongs to</param>

        /// <returns>Created</returns>

        System.Threading.Tasks.Task StartReplicationAsync(string x_Request_Id, StartReplicationExecution execution);

        /// <summary>
        /// Get the specific replication execution
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="id">The ID of the execution.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<ReplicationExecution> GetReplicationExecutionAsync(string x_Request_Id, long id);

        /// <summary>
        /// Stop the specific replication execution
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="id">The ID of the execution.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task StopReplicationAsync(string x_Request_Id, long id);

        /// <summary>
        /// List replication tasks for a specific execution
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <param name="id">The ID of the execution that the tasks belongs to.</param>

        /// <param name="status">The task status.</param>

        /// <param name="resource_type">The resource type.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ReplicationTask>> ListReplicationTasksAsync(string x_Request_Id, string sort, long page, long page_size, long id, string status, string resource_type);

        /// <summary>
        /// Get the log of the specific replication task
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="id">The ID of the execution that the tasks belongs to.</param>

        /// <param name="task_id">The ID of the task.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<string> GetReplicationLogAsync(string x_Request_Id, long id, long task_id);

        /// <summary>
        /// List registry adapters
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <returns>Success.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ListRegistryProviderTypesAsync(string x_Request_Id);

        /// <summary>
        /// List all registered registry provider information
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <returns>Success.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, RegistryProviderInfo>> ListRegistryProviderInfosAsync(string x_Request_Id);

        /// <summary>
        /// Create a registry
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="registry">The registry</param>

        /// <returns>Created</returns>

        System.Threading.Tasks.Task CreateRegistryAsync(string x_Request_Id, Registry registry);

        /// <summary>
        /// List the registries
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <param name="name">Deprecated, use `q` instead.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Registry>> ListRegistriesAsync(string x_Request_Id, string q, string sort, long page, long page_size, string name);

        /// <summary>
        /// Check status of a registry
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="registry">The registry</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task PingRegistryAsync(string x_Request_Id, RegistryPing registry);

        /// <summary>
        /// Get the specific registry
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="id">Registry ID</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<Registry> GetRegistryAsync(string x_Request_Id, long id);

        /// <summary>
        /// Delete the specific registry
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="id">Registry ID</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task DeleteRegistryAsync(string x_Request_Id, long id);

        /// <summary>
        /// Update the registry
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="id">The registry ID</param>

        /// <param name="registry">The registry</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task UpdateRegistryAsync(string x_Request_Id, long id, RegistryUpdate registry);

        /// <summary>
        /// Get the registry info
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="id">Registry ID</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<RegistryInfo> GetRegistryInfoAsync(string x_Request_Id, long id);

        /// <summary>
        /// Get the metrics of the latest scan all process
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <returns>OK</returns>

        System.Threading.Tasks.Task<Stats> GetLatestScanAllMetricsAsync(string x_Request_Id);

        /// <summary>
        /// Get the metrics of the latest scheduled scan all process
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <returns>OK</returns>

        [System.Obsolete]

        System.Threading.Tasks.Task<Stats> GetLatestScheduledScanAllMetricsAsync(string x_Request_Id);

        /// <summary>
        /// Get general system info
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <returns>Get general info successfully.</returns>

        System.Threading.Tasks.Task<GeneralInfo> GetSystemInfoAsync(string x_Request_Id);

        /// <summary>
        /// Get system volume info (total/free size).
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <returns>Get system volumes successfully.</returns>

        System.Threading.Tasks.Task<SystemInfo> GetVolumesAsync(string x_Request_Id);

        /// <summary>
        /// Get default root certificate.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <returns>Get default root certificate successfully.</returns>

        System.Threading.Tasks.Task<FileResult> GetCertAsync(string x_Request_Id);

        /// <summary>
        /// Test the OIDC endpoint.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="endpoint">Request body for OIDC endpoint to be tested.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task PingOIDCAsync(string x_Request_Id, Endpoint endpoint);

        /// <summary>
        /// Get gc results.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <returns>Get gc results successfully.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<GCHistory>> GetGCHistoryAsync(string x_Request_Id, string q, string sort, long page, long page_size);

        /// <summary>
        /// Get gc status.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="gc_id">The ID of the gc log</param>

        /// <returns>Get gc results successfully.</returns>

        System.Threading.Tasks.Task<GCHistory> GetGCAsync(string x_Request_Id, long gc_id);

        /// <summary>
        /// Stop the specific GC execution
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="gc_id">The ID of the gc log</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task StopGCAsync(string x_Request_Id, long gc_id);

        /// <summary>
        /// Get gc job log.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="gc_id">The ID of the gc log</param>

        /// <returns>Get successfully.</returns>

        System.Threading.Tasks.Task<string> GetGCLogAsync(string x_Request_Id, long gc_id);

        /// <summary>
        /// Get gc's schedule.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <returns>Get gc's schedule.</returns>

        System.Threading.Tasks.Task<GCHistory> GetGCScheduleAsync(string x_Request_Id);

        /// <summary>
        /// Create a gc schedule.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="schedule">Updates of gc's schedule.</param>

        /// <returns>Created</returns>

        System.Threading.Tasks.Task CreateGCScheduleAsync(string x_Request_Id, Schedule schedule);

        /// <summary>
        /// Update gc's schedule.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="schedule">Updates of gc's schedule.</param>

        /// <returns>Updated gc's schedule successfully.</returns>

        System.Threading.Tasks.Task UpdateGCScheduleAsync(string x_Request_Id, Schedule schedule);

        /// <summary>
        /// Get purge job results.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <returns>Get purge job results successfully.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ExecHistory>> GetPurgeHistoryAsync(string x_Request_Id, string q, string sort, long page, long page_size);

        /// <summary>
        /// Get purge job status.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="purge_id">The ID of the purge log</param>

        /// <returns>Get purge job results successfully.</returns>

        System.Threading.Tasks.Task<ExecHistory> GetPurgeJobAsync(string x_Request_Id, long purge_id);

        /// <summary>
        /// Stop the specific purge audit log execution
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="purge_id">The ID of the purge log</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task StopPurgeAsync(string x_Request_Id, long purge_id);

        /// <summary>
        /// Get purge job log.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="purge_id">The ID of the purge log</param>

        /// <returns>Get successfully.</returns>

        System.Threading.Tasks.Task<string> GetPurgeJobLogAsync(string x_Request_Id, long purge_id);

        /// <summary>
        /// Get purge's schedule.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <returns>Get purge job's schedule.</returns>

        System.Threading.Tasks.Task<ExecHistory> GetPurgeScheduleAsync(string x_Request_Id);

        /// <summary>
        /// Create a purge job schedule.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="schedule">The purge job's schedule, it is a json object. ｜
        /// <br/>The sample format is ｜
        /// <br/>{"parameters":{"audit_retention_hour":168,"dry_run":true, "include_operations":"create,delete,pull"},"schedule":{"type":"Hourly","cron":"0 0 * * * *"}} ｜
        /// <br/>the include_operation should be a comma separated string, e.g. create,delete,pull, if it is empty, no operation will be purged.</param>

        /// <returns>Created</returns>

        System.Threading.Tasks.Task CreatePurgeScheduleAsync(string x_Request_Id, Schedule schedule);

        /// <summary>
        /// Update purge job's schedule.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="schedule">The purge job's schedule, it is a json object. ｜
        /// <br/>The sample format is ｜
        /// <br/>{"parameters":{"audit_retention_hour":168,"dry_run":true, "include_operations":"create,delete,pull"},"schedule":{"type":"Hourly","cron":"0 0 * * * *"}} ｜
        /// <br/>the include_operation should be a comma separated string, e.g. create,delete,pull, if it is empty, no operation will be purged.</param>

        /// <returns>Updated purge's schedule successfully.</returns>

        System.Threading.Tasks.Task UpdatePurgeScheduleAsync(string x_Request_Id, Schedule schedule);

        /// <summary>
        /// Get the system level allowlist of CVE.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <returns>Successfully retrieved the CVE allowlist.</returns>

        System.Threading.Tasks.Task<CVEAllowlist> GetSystemCVEAllowlistAsync(string x_Request_Id);

        /// <summary>
        /// Update the system level allowlist of CVE.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="allowlist">The allowlist with new content</param>

        /// <returns>Successfully updated the CVE allowlist.</returns>

        System.Threading.Tasks.Task PutSystemCVEAllowlistAsync(string x_Request_Id, CVEAllowlist allowlist);

        /// <summary>
        /// Get scan all's schedule.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <returns>Get a schedule for the scan all job, which scans all of images in Harbor.</returns>

        System.Threading.Tasks.Task<Schedule> GetScanAllScheduleAsync(string x_Request_Id);

        /// <summary>
        /// Update scan all's schedule.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="schedule">Updates the schedule of scan all job, which scans all of images in Harbor.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task UpdateScanAllScheduleAsync(string x_Request_Id, Schedule schedule);

        /// <summary>
        /// Create a schedule or a manual trigger for the scan all job.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="schedule">Create a schedule or a manual trigger for the scan all job.</param>

        /// <returns>Created</returns>

        System.Threading.Tasks.Task CreateScanAllScheduleAsync(string x_Request_Id, Schedule schedule);

        /// <summary>
        /// Stop scanAll job execution
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <returns>Accepted</returns>

        System.Threading.Tasks.Task StopScanAllAsync(string x_Request_Id);

        /// <summary>
        /// Ping Harbor to check if it's alive.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <returns>The API server is alive</returns>

        System.Threading.Tasks.Task<string> GetPingAsync(string x_Request_Id);

        /// <summary>
        /// Get Retention Metadatas
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <returns>Get Retention Metadatas successfully.</returns>

        System.Threading.Tasks.Task<RetentionMetadata> GetRentenitionMetadataAsync(string x_Request_Id);

        /// <summary>
        /// Create Retention Policy
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="policy">Create Retention Policy successfully.</param>

        /// <returns>Created</returns>

        System.Threading.Tasks.Task CreateRetentionAsync(string x_Request_Id, RetentionPolicy policy);

        /// <summary>
        /// Get Retention Policy
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="id">Retention ID.</param>

        /// <returns>Get Retention Policy successfully.</returns>

        System.Threading.Tasks.Task<RetentionPolicy> GetRetentionAsync(string x_Request_Id, long id);

        /// <summary>
        /// Update Retention Policy
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="id">Retention ID.</param>


        /// <returns>Update Retention Policy successfully.</returns>

        System.Threading.Tasks.Task UpdateRetentionAsync(string x_Request_Id, long id, RetentionPolicy policy);

        /// <summary>
        /// Delete Retention Policy
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="id">Retention ID.</param>

        /// <returns>Update Retention Policy successfully.</returns>

        System.Threading.Tasks.Task DeleteRetentionAsync(string x_Request_Id, long id);

        /// <summary>
        /// Trigger a Retention Execution
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="id">Retention ID.</param>


        /// <returns>Trigger a Retention job successfully.</returns>

        System.Threading.Tasks.Task TriggerRetentionExecutionAsync(string x_Request_Id, long id, Body body);

        /// <summary>
        /// Get Retention executions
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="id">Retention ID.</param>

        /// <param name="page">The page number.</param>

        /// <param name="page_size">The size of per page.</param>

        /// <returns>Get a Retention execution successfully.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RetentionExecution>> ListRetentionExecutionsAsync(string x_Request_Id, long id, long? page, long? page_size);

        /// <summary>
        /// Stop a Retention execution
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="id">Retention ID.</param>

        /// <param name="eid">Retention execution ID.</param>

        /// <param name="body">The action, only support "stop" now.</param>

        /// <returns>Stop a Retention job successfully.</returns>

        System.Threading.Tasks.Task OperateRetentionExecutionAsync(string x_Request_Id, long id, long eid, Body2 body);

        /// <summary>
        /// Get Retention tasks
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="id">Retention ID.</param>

        /// <param name="eid">Retention execution ID.</param>

        /// <param name="page">The page number.</param>

        /// <param name="page_size">The size of per page.</param>

        /// <returns>Get Retention job tasks successfully.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RetentionExecutionTask>> ListRetentionTasksAsync(string x_Request_Id, long id, long eid, long? page, long? page_size);

        /// <summary>
        /// Get Retention job task log
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="id">Retention ID.</param>

        /// <param name="eid">Retention execution ID.</param>

        /// <param name="tid">Retention execution ID.</param>

        /// <returns>Get Retention job task log successfully.</returns>

        System.Threading.Tasks.Task<string> GetRetentionTaskLogAsync(string x_Request_Id, long id, long eid, long tid);

        /// <summary>
        /// List scanner registrations
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <returns>A list of scanner registrations.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ScannerRegistration>> ListScannersAsync(string x_Request_Id, string q, string sort, long page, long page_size);

        /// <summary>
        /// Create a scanner registration
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="registration">A scanner registration to be created.</param>

        /// <returns>Created successfully</returns>

        System.Threading.Tasks.Task CreateScannerAsync(string x_Request_Id, ScannerRegistrationReq registration);

        /// <summary>
        /// Tests scanner registration settings
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="settings">A scanner registration settings to be tested.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task PingScannerAsync(string x_Request_Id, ScannerRegistrationSettings settings);

        /// <summary>
        /// Get a scanner registration details
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="registration_id">The scanner registration identifer.</param>

        /// <returns>The details of the scanner registration.</returns>

        System.Threading.Tasks.Task<ScannerRegistration> GetScannerAsync(string x_Request_Id, string registration_id);

        /// <summary>
        /// Update a scanner registration
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="registration_id">The scanner registration identifier.</param>

        /// <param name="registration">A scanner registraiton to be updated.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task UpdateScannerAsync(string x_Request_Id, string registration_id, ScannerRegistrationReq registration);

        /// <summary>
        /// Delete a scanner registration
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="registration_id">The scanner registration identifier.</param>

        /// <returns>Deleted successfully and return the deleted registration</returns>

        System.Threading.Tasks.Task<ScannerRegistration> DeleteScannerAsync(string x_Request_Id, string registration_id);

        /// <summary>
        /// Set system default scanner registration
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="registration_id">The scanner registration identifier.</param>


        /// <returns>Successfully set the specified scanner registration as system default</returns>

        System.Threading.Tasks.Task SetScannerAsDefaultAsync(string x_Request_Id, string registration_id, IsDefault payload);

        /// <summary>
        /// Get the metadata of the specified scanner registration
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="registration_id">The scanner registration identifier.</param>

        /// <returns>The metadata of the specified scanner adapter</returns>

        System.Threading.Tasks.Task<ScannerAdapterMetadata> GetScannerMetadataAsync(string x_Request_Id, string registration_id);

        /// <summary>
        /// List users
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <returns>return the list of users.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<UserResp>> ListUsersAsync(string x_Request_Id, string q, string sort, long page, long page_size);

        /// <summary>
        /// Create a local user.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="userReq">The new user</param>

        /// <returns>Created</returns>

        System.Threading.Tasks.Task CreateUserAsync(string x_Request_Id, UserCreationReq userReq);

        /// <summary>
        /// Get current user info.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <returns>Get current user information successfully.</returns>

        System.Threading.Tasks.Task<UserResp> GetCurrentUserInfoAsync(string x_Request_Id);

        /// <summary>
        /// Search users by username
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <param name="username">Username for filtering results.</param>

        /// <returns>Search users by username successfully.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<UserSearchRespItem>> SearchUsersAsync(string x_Request_Id, long page, long page_size, string username);

        /// <summary>
        /// Get a user's profile.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>


        /// <returns>Get user's info successfully.</returns>

        System.Threading.Tasks.Task<UserResp> GetUserAsync(string x_Request_Id, int user_id);

        /// <summary>
        /// Update user's profile.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="user_id">Registered user ID</param>

        /// <param name="profile">Only email, realname and comment can be modified.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task UpdateUserProfileAsync(string x_Request_Id, int user_id, UserProfile profile);

        /// <summary>
        /// Mark a registered user as be removed.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="user_id">User ID for marking as to be removed.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task DeleteUserAsync(string x_Request_Id, int user_id);

        /// <summary>
        /// Update a registered user to change to be an administrator of Harbor.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>


        /// <param name="sysadmin_flag">Toggle a user to admin or not.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task SetUserSysAdminAsync(string x_Request_Id, int user_id, UserSysAdminFlag sysadmin_flag);

        /// <summary>
        /// Change the password on a user that already exists.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>


        /// <param name="password">Password to be updated, the attribute 'old_password' is optional when the API is called by the system administrator.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task UpdateUserPasswordAsync(string x_Request_Id, int user_id, PasswordReq password);

        /// <summary>
        /// Get current user permissions.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="scope">The scope for the permission</param>

        /// <param name="relative">If true, the resources in the response are relative to the scope,
        /// <br/>eg for resource '/project/1/repository' if relative is 'true' then the resource in response will be 'repository'.</param>

        /// <returns>Get current user permission successfully.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Permission>> GetCurrentUserPermissionsAsync(string x_Request_Id, string scope, bool? relative);

        /// <summary>
        /// Set CLI secret for a user.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="user_id">User ID</param>


        /// <returns>The secret is successfully updated</returns>

        System.Threading.Tasks.Task SetCliSecretAsync(string x_Request_Id, int user_id, OIDCCliSecretReq secret);

        /// <summary>
        /// List labels according to the query strings.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>

        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>

        /// <param name="page">The page number</param>

        /// <param name="page_size">The size of per page</param>

        /// <param name="name">The label name.</param>

        /// <param name="scope">The label scope. Valid values are g and p. g for global labels and p for project labels.</param>

        /// <param name="project_id">Relevant project ID, required when scope is p.</param>

        /// <returns>Get successfully.</returns>

        System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Label>> ListLabelsAsync(string x_Request_Id, string q, string sort, long page, long page_size, string name, string scope, long? project_id);

        /// <summary>
        /// Post creates a label
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="label">The json object of label.</param>

        /// <returns>Create successfully.</returns>

        System.Threading.Tasks.Task CreateLabelAsync(string x_Request_Id, Label label);

        /// <summary>
        /// Get the label specified by ID.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="label_id">Label ID</param>

        /// <returns>Get successfully.</returns>

        System.Threading.Tasks.Task<Label> GetLabelByIDAsync(string x_Request_Id, long label_id);

        /// <summary>
        /// Update the label properties.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="label_id">Label ID</param>

        /// <param name="label">The updated label json object.</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task UpdateLabelAsync(string x_Request_Id, long label_id, Label label);

        /// <summary>
        /// Delete the label specified by ID.
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="label_id">Label ID</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task DeleteLabelAsync(string x_Request_Id, long label_id);

        /// <summary>
        /// Export scan data for selected projects
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="x_Scan_Data_Type">The type of scan data to export</param>

        /// <param name="criteria">The criteria for the export</param>

        /// <returns>Success.</returns>

        System.Threading.Tasks.Task<ScanDataExportJob> ExportScanDataAsync(string x_Request_Id, string x_Scan_Data_Type, ScanDataExportRequest criteria);

        /// <summary>
        /// Get the specific scan data export execution
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="execution_id">Execution ID</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<ScanDataExportExecution> GetScanDataExportExecutionAsync(string x_Request_Id, int execution_id);

        /// <summary>
        /// Get a list of specific scan data export execution jobs for a specified user
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <returns>Success</returns>

        System.Threading.Tasks.Task<ScanDataExportExecutionList> GetScanDataExportExecutionListAsync(string x_Request_Id);

        /// <summary>
        /// Download the scan data export file
        /// </summary>

        /// <param name="x_Request_Id">An unique ID for the request</param>

        /// <param name="execution_id">Execution ID</param>

        /// <param name="format">The format of the data to be exported. e.g. CSV or PDF</param>

        /// <returns>Data file containing the export data</returns>

        System.Threading.Tasks.Task<FileResult> DownloadScanDataAsync(string x_Request_Id, int execution_id, string format);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    [Microsoft.AspNetCore.Mvc.Route("api/v2.0")]

    public partial class Controller : Microsoft.AspNetCore.Mvc.ControllerBase
    {
        private IController _implementation;

        public Controller(IController implementation)
        {
            _implementation = implementation;
        }

        /// <summary>
        /// Check the status of Harbor components
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>The health status of Harbor components</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("health")]
        public System.Threading.Tasks.Task<OverallHealthStatus> GetHealth([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id)
        {

            return _implementation.GetHealthAsync(x_Request_Id);
        }

        /// <summary>
        /// Search for projects, repositories and helm charts
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="q">Search parameter for project and repository name.</param>
        /// <returns>An array of search results</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("search")]
        public System.Threading.Tasks.Task<Search> Search([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] string q)
        {

            return _implementation.SearchAsync(x_Request_Id, q);
        }

        /// <summary>
        /// Get the statistic information about the projects and repositories
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>The statistic information</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("statistics")]
        public System.Threading.Tasks.Task<Statistic> GetStatistic([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id)
        {

            return _implementation.GetStatisticAsync(x_Request_Id);
        }

        /// <summary>
        /// Ping available ldap service.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="ldapconf">ldap configuration. support input ldap service configuration. If it is a empty request, will load current configuration from the system.</param>
        /// <returns>Ping ldap service successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("ldap/ping")]
        public System.Threading.Tasks.Task<LdapPingResult> PingLdap([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] LdapConf ldapconf)
        {

            return _implementation.PingLdapAsync(x_Request_Id, ldapconf);
        }

        /// <summary>
        /// Search available ldap users.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="username">Registered user ID</param>
        /// <returns>Search ldap users successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("ldap/users/search")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<LdapUser>> SearchLdapUser([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] string username)
        {

            return _implementation.SearchLdapUserAsync(x_Request_Id, username);
        }

        /// <summary>
        /// Import selected available ldap users.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="uid_list">The uid listed for importing. This list will check users validity of ldap service based on configuration from the system.</param>
        /// <returns>Add ldap users successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("ldap/users/import")]
        public System.Threading.Tasks.Task ImportLdapUser([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] LdapImportUsers uid_list)
        {

            return _implementation.ImportLdapUserAsync(x_Request_Id, uid_list);
        }

        /// <summary>
        /// Search available ldap groups.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="groupname">Ldap group name</param>
        /// <param name="groupdn">The LDAP group DN</param>
        /// <returns>Search ldap group successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("ldap/groups/search")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<UserGroup>> SearchLdapGroup([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] string groupname, [Microsoft.AspNetCore.Mvc.FromQuery] string groupdn)
        {

            return _implementation.SearchLdapGroupAsync(x_Request_Id, groupname, groupdn);
        }

        /// <summary>
        /// Get internal configurations.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>Get system configurations successfully. The response body is a map.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("internalconfig")]
        public System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, InternalConfigurationValue>> GetInternalconfig([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id)
        {

            return _implementation.GetInternalconfigAsync(x_Request_Id);
        }

        /// <summary>
        /// Get system configurations.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>Get system configurations successfully. The response body is a map.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("configurations")]
        public System.Threading.Tasks.Task<ConfigurationsResponse> GetConfigurations([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id)
        {

            return _implementation.GetConfigurationsAsync(x_Request_Id);
        }

        /// <summary>
        /// Modify system configurations.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="configurations">The configuration map can contain a subset of the attributes of the schema, which are to be updated.</param>
        /// <returns>Modify system configurations successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("configurations")]
        public System.Threading.Tasks.Task UpdateConfigurations([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] Configurations configurations)
        {

            return _implementation.UpdateConfigurationsAsync(x_Request_Id, configurations);
        }

        /// <summary>
        /// List projects
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <param name="name">The name of project.</param>
        /// <param name="@public">The project is public or private.</param>
        /// <param name="owner">The name of project owner.</param>
        /// <param name="with_detail">Bool value indicating whether return detailed information of the project</param>
        /// <returns>Return all matched projects.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Project>> ListProjects([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size, [Microsoft.AspNetCore.Mvc.FromQuery] string sort, [Microsoft.AspNetCore.Mvc.FromQuery] string name, [Microsoft.AspNetCore.Mvc.FromQuery(Name = "public")] bool? @public, [Microsoft.AspNetCore.Mvc.FromQuery] string owner, [Microsoft.AspNetCore.Mvc.FromQuery] bool? with_detail)
        {

            return _implementation.ListProjectsAsync(x_Request_Id, q, page ?? 1L, page_size ?? 10L, sort, name, @public, owner, with_detail ?? true);
        }

        /// <summary>
        /// Check if the project name user provided already exists.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">Project name for checking exists.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpHead, Microsoft.AspNetCore.Mvc.Route("projects")]
        public System.Threading.Tasks.Task HeadProject([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] string project_name)
        {

            return _implementation.HeadProjectAsync(x_Request_Id, project_name);
        }

        /// <summary>
        /// Create a new project.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Resource_Name_In_Location">The flag to indicate whether to return the name of the resource in Location. When X-Resource-Name-In-Location is true, the Location will return the name of the resource.</param>
        /// <param name="project">New created project.</param>
        /// <returns>Created</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("projects")]
        public System.Threading.Tasks.Task CreateProject([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Resource-Name-In-Location")] bool? x_Resource_Name_In_Location, [Microsoft.AspNetCore.Mvc.FromBody] ProjectReq project)
        {

            return _implementation.CreateProjectAsync(x_Request_Id, x_Resource_Name_In_Location ?? false, project);
        }

        /// <summary>
        /// Return specific project detail information
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <returns>Return matched project information.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}")]
        public System.Threading.Tasks.Task<Project> GetProject([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id)
        {

            return _implementation.GetProjectAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id);
        }

        /// <summary>
        /// Update properties for a selected project.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="project">Updates of project.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}")]
        public System.Threading.Tasks.Task UpdateProject([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, [Microsoft.AspNetCore.Mvc.FromBody] ProjectReq project)
        {

            return _implementation.UpdateProjectAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, project);
        }

        /// <summary>
        /// Delete project by projectID
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}")]
        public System.Threading.Tasks.Task DeleteProject([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id)
        {

            return _implementation.DeleteProjectAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id);
        }

        /// <summary>
        /// Get the deletable status of the project
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <returns>Return deletable status of the project.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/_deletable")]
        public System.Threading.Tasks.Task<ProjectDeletable> GetProjectDeletable([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id)
        {

            return _implementation.GetProjectDeletableAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id);
        }

        /// <summary>
        /// Get summary of the project.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <returns>Get summary of the project successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/summary")]
        public System.Threading.Tasks.Task<ProjectSummary> GetProjectSummary([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id)
        {

            return _implementation.GetProjectSummaryAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id);
        }

        /// <summary>
        /// Get all project member information
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <param name="entityname">The entity name to search.</param>
        /// <returns>Get project members successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/members")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ProjectMemberEntity>> ListProjectMembers([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size, [Microsoft.AspNetCore.Mvc.FromQuery] string entityname)
        {

            return _implementation.ListProjectMembersAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, page ?? 1L, page_size ?? 10L, entityname);
        }

        /// <summary>
        /// Create project member
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <returns>Project member created successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/members")]
        public System.Threading.Tasks.Task CreateProjectMember([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, [Microsoft.AspNetCore.Mvc.FromBody] ProjectMember project_member)
        {

            return _implementation.CreateProjectMemberAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, project_member);
        }

        /// <summary>
        /// Get the project member information
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="mid">The member ID</param>
        /// <returns>Project member retrieved successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/members/{mid}")]
        public System.Threading.Tasks.Task<ProjectMemberEntity> GetProjectMember([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, long mid)
        {

            return _implementation.GetProjectMemberAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, mid);
        }

        /// <summary>
        /// Update project member
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="mid">Member ID.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/members/{mid}")]
        public System.Threading.Tasks.Task UpdateProjectMember([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, long mid, [Microsoft.AspNetCore.Mvc.FromBody] RoleRequest role)
        {

            return _implementation.UpdateProjectMemberAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, mid, role);
        }

        /// <summary>
        /// Delete project member
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="mid">Member ID.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/members/{mid}")]
        public System.Threading.Tasks.Task DeleteProjectMember([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, long mid)
        {

            return _implementation.DeleteProjectMemberAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, mid);
        }

        /// <summary>
        /// Get the metadata of the specific project
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/metadatas/")]
        public System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, string>> ListProjectMetadatas([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id)
        {

            return _implementation.ListProjectMetadatasAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id);
        }

        /// <summary>
        /// Add metadata for the specific project
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/metadatas/")]
        public System.Threading.Tasks.Task AddProjectMetadatas([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, [Microsoft.AspNetCore.Mvc.FromBody] System.Collections.Generic.IDictionary<string, string> metadata)
        {

            return _implementation.AddProjectMetadatasAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, metadata);
        }

        /// <summary>
        /// Get the specific metadata of the specific project
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="meta_name">The name of metadata.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/metadatas/{meta_name}")]
        public System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, string>> GetProjectMetadata([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, string meta_name)
        {

            return _implementation.GetProjectMetadataAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, meta_name);
        }

        /// <summary>
        /// Update the specific metadata for the specific project
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="meta_name">The name of metadata.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/metadatas/{meta_name}")]
        public System.Threading.Tasks.Task UpdateProjectMetadata([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, string meta_name, [Microsoft.AspNetCore.Mvc.FromBody] System.Collections.Generic.IDictionary<string, string> metadata)
        {

            return _implementation.UpdateProjectMetadataAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, meta_name, metadata);
        }

        /// <summary>
        /// Delete the specific metadata for the specific project
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="meta_name">The name of metadata.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/metadatas/{meta_name}")]
        public System.Threading.Tasks.Task DeleteProjectMetadata([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, string meta_name)
        {

            return _implementation.DeleteProjectMetadataAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, meta_name);
        }

        /// <summary>
        /// List all authorized repositories
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("repositories")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Repository>> ListAllRepositories([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size)
        {

            return _implementation.ListAllRepositoriesAsync(x_Request_Id, q, sort, page ?? 1L, page_size ?? 10L);
        }

        /// <summary>
        /// List repositories
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/repositories")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Repository>> ListRepositories([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size)
        {

            return _implementation.ListRepositoriesAsync(x_Request_Id, project_name, q, sort, page ?? 1L, page_size ?? 10L);
        }

        /// <summary>
        /// Get repository
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/repositories/{repository_name}")]
        public System.Threading.Tasks.Task<Repository> GetRepository([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string repository_name)
        {

            return _implementation.GetRepositoryAsync(x_Request_Id, project_name, repository_name);
        }

        /// <summary>
        /// Update repository
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>
        /// <param name="repository">The JSON object of repository.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/repositories/{repository_name}")]
        public System.Threading.Tasks.Task UpdateRepository([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string repository_name, [Microsoft.AspNetCore.Mvc.FromBody] Repository repository)
        {

            return _implementation.UpdateRepositoryAsync(x_Request_Id, project_name, repository_name, repository);
        }

        /// <summary>
        /// Delete repository
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/repositories/{repository_name}")]
        public System.Threading.Tasks.Task DeleteRepository([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string repository_name)
        {

            return _implementation.DeleteRepositoryAsync(x_Request_Id, project_name, repository_name);
        }

        /// <summary>
        /// List artifacts
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <param name="x_Accept_Vulnerabilities">A comma-separated lists of MIME types for the scan report or scan summary. The first mime type will be used when the report found for it.
        /// <br/>Currently the mime type supports 'application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0' and 'application/vnd.security.vulnerability.report; version=1.1'</param>
        /// <param name="with_tag">Specify whether the tags are included inside the returning artifacts</param>
        /// <param name="with_label">Specify whether the labels are included inside the returning artifacts</param>
        /// <param name="with_scan_overview">Specify whether the scan overview is included inside the returning artifacts</param>
        /// <param name="with_signature">Specify whether the signature is included inside the tags of the returning artifacts. Only works when setting "with_tag=true"</param>
        /// <param name="with_immutable_status">Specify whether the immutable status is included inside the tags of the returning artifacts. Only works when setting "with_immutable_status=true"</param>
        /// <param name="with_accessory">Specify whether the accessories are included of the returning artifacts. Only works when setting "with_accessory=true"</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/repositories/{repository_name}/artifacts")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Artifact>> ListArtifacts([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string repository_name, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Accept-Vulnerabilities")] string x_Accept_Vulnerabilities, [Microsoft.AspNetCore.Mvc.FromQuery] bool? with_tag, [Microsoft.AspNetCore.Mvc.FromQuery] bool? with_label, [Microsoft.AspNetCore.Mvc.FromQuery] bool? with_scan_overview, [Microsoft.AspNetCore.Mvc.FromQuery] bool? with_signature, [Microsoft.AspNetCore.Mvc.FromQuery] bool? with_immutable_status, [Microsoft.AspNetCore.Mvc.FromQuery] bool? with_accessory)
        {

            return _implementation.ListArtifactsAsync(x_Request_Id, project_name, repository_name, q, sort, page ?? 1L, page_size ?? 10L, x_Accept_Vulnerabilities ?? "application/vnd.security.vulnerability.report; version=1.1, application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0", with_tag ?? true, with_label ?? false, with_scan_overview ?? false, with_signature ?? false, with_immutable_status ?? false, with_accessory ?? false);
        }

        /// <summary>
        /// Copy artifact
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>
        /// <param name="from">The artifact from which the new artifact is copied from, the format should be "project/repository:tag" or "project/repository@digest".</param>
        /// <returns>Created</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/repositories/{repository_name}/artifacts")]
        public System.Threading.Tasks.Task CopyArtifact([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string repository_name, [Microsoft.AspNetCore.Mvc.FromQuery] string from)
        {

            return _implementation.CopyArtifactAsync(x_Request_Id, project_name, repository_name, from);
        }

        /// <summary>
        /// Get the specific artifact
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>
        /// <param name="reference">The reference of the artifact, can be digest or tag</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <param name="x_Accept_Vulnerabilities">A comma-separated lists of MIME types for the scan report or scan summary. The first mime type will be used when the report found for it.
        /// <br/>Currently the mime type supports 'application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0' and 'application/vnd.security.vulnerability.report; version=1.1'</param>
        /// <param name="with_tag">Specify whether the tags are inclued inside the returning artifacts</param>
        /// <param name="with_label">Specify whether the labels are inclued inside the returning artifacts</param>
        /// <param name="with_scan_overview">Specify whether the scan overview is inclued inside the returning artifacts</param>
        /// <param name="with_accessory">Specify whether the accessories are included of the returning artifacts.</param>
        /// <param name="with_signature">Specify whether the signature is inclued inside the returning artifacts</param>
        /// <param name="with_immutable_status">Specify whether the immutable status is inclued inside the tags of the returning artifacts.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/repositories/{repository_name}/artifacts/{reference}")]
        public System.Threading.Tasks.Task<Artifact> GetArtifact([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string repository_name, string reference, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Accept-Vulnerabilities")] string x_Accept_Vulnerabilities, [Microsoft.AspNetCore.Mvc.FromQuery] bool? with_tag, [Microsoft.AspNetCore.Mvc.FromQuery] bool? with_label, [Microsoft.AspNetCore.Mvc.FromQuery] bool? with_scan_overview, [Microsoft.AspNetCore.Mvc.FromQuery] bool? with_accessory, [Microsoft.AspNetCore.Mvc.FromQuery] bool? with_signature, [Microsoft.AspNetCore.Mvc.FromQuery] bool? with_immutable_status)
        {

            return _implementation.GetArtifactAsync(x_Request_Id, project_name, repository_name, reference, page ?? 1L, page_size ?? 10L, x_Accept_Vulnerabilities ?? "application/vnd.security.vulnerability.report; version=1.1, application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0", with_tag ?? true, with_label ?? false, with_scan_overview ?? false, with_accessory ?? false, with_signature ?? false, with_immutable_status ?? false);
        }

        /// <summary>
        /// Delete the specific artifact
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>
        /// <param name="reference">The reference of the artifact, can be digest or tag</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/repositories/{repository_name}/artifacts/{reference}")]
        public System.Threading.Tasks.Task DeleteArtifact([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string repository_name, string reference)
        {

            return _implementation.DeleteArtifactAsync(x_Request_Id, project_name, repository_name, reference);
        }

        /// <summary>
        /// Scan the artifact
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>
        /// <param name="reference">The reference of the artifact, can be digest or tag</param>
        /// <returns>Accepted</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan")]
        public System.Threading.Tasks.Task ScanArtifact([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string repository_name, string reference)
        {

            return _implementation.ScanArtifactAsync(x_Request_Id, project_name, repository_name, reference);
        }

        /// <summary>
        /// Cancelling a scan job for a particular artifact
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>
        /// <param name="reference">The reference of the artifact, can be digest or tag</param>
        /// <returns>Accepted</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan/stop")]
        public System.Threading.Tasks.Task StopScanArtifact([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string repository_name, string reference)
        {

            return _implementation.StopScanArtifactAsync(x_Request_Id, project_name, repository_name, reference);
        }

        /// <summary>
        /// Get the log of the scan report
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>
        /// <param name="reference">The reference of the artifact, can be digest or tag</param>
        /// <param name="report_id">The report id to get the log</param>
        /// <returns>Successfully get scan log file</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/scan/{report_id}/log")]
        public System.Threading.Tasks.Task<string> GetReportLog([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string repository_name, string reference, string report_id)
        {

            return _implementation.GetReportLogAsync(x_Request_Id, project_name, repository_name, reference, report_id);
        }

        /// <summary>
        /// Create tag
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>
        /// <param name="reference">The reference of the artifact, can be digest or tag</param>
        /// <param name="tag">The JSON object of tag.</param>
        /// <returns>Created</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags")]
        public System.Threading.Tasks.Task CreateTag([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string repository_name, string reference, [Microsoft.AspNetCore.Mvc.FromBody] Tag tag)
        {

            return _implementation.CreateTagAsync(x_Request_Id, project_name, repository_name, reference, tag);
        }

        /// <summary>
        /// List tags
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>
        /// <param name="reference">The reference of the artifact, can be digest or tag</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <param name="with_signature">Specify whether the signature is included inside the returning tags</param>
        /// <param name="with_immutable_status">Specify whether the immutable status is included inside the returning tags</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Tag>> ListTags([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string repository_name, string reference, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size, [Microsoft.AspNetCore.Mvc.FromQuery] bool? with_signature, [Microsoft.AspNetCore.Mvc.FromQuery] bool? with_immutable_status)
        {

            return _implementation.ListTagsAsync(x_Request_Id, project_name, repository_name, reference, q, sort, page ?? 1L, page_size ?? 10L, with_signature ?? false, with_immutable_status ?? false);
        }

        /// <summary>
        /// Delete tag
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>
        /// <param name="reference">The reference of the artifact, can be digest or tag</param>
        /// <param name="tag_name">The name of the tag</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/tags/{tag_name}")]
        public System.Threading.Tasks.Task DeleteTag([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string repository_name, string reference, string tag_name)
        {

            return _implementation.DeleteTagAsync(x_Request_Id, project_name, repository_name, reference, tag_name);
        }

        /// <summary>
        /// List accessories
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>
        /// <param name="reference">The reference of the artifact, can be digest or tag</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/accessories")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Accessory>> ListAccessories([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string repository_name, string reference, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size)
        {

            return _implementation.ListAccessoriesAsync(x_Request_Id, project_name, repository_name, reference, q, sort, page ?? 1L, page_size ?? 10L);
        }

        /// <summary>
        /// Get the vulnerabilities addition of the specific artifact
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>
        /// <param name="reference">The reference of the artifact, can be digest or tag</param>
        /// <param name="x_Accept_Vulnerabilities">A comma-separated lists of MIME types for the scan report or scan summary. The first mime type will be used when the report found for it.
        /// <br/>Currently the mime type supports 'application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0' and 'application/vnd.security.vulnerability.report; version=1.1'</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/additions/vulnerabilities")]
        public System.Threading.Tasks.Task<string> GetVulnerabilitiesAddition([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string repository_name, string reference, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Accept-Vulnerabilities")] string x_Accept_Vulnerabilities)
        {

            return _implementation.GetVulnerabilitiesAdditionAsync(x_Request_Id, project_name, repository_name, reference, x_Accept_Vulnerabilities ?? "application/vnd.security.vulnerability.report; version=1.1, application/vnd.scanner.adapter.vuln.report.harbor+json; version=1.0");
        }

        /// <summary>
        /// Get the addition of the specific artifact
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>
        /// <param name="reference">The reference of the artifact, can be digest or tag</param>
        /// <param name="addition">The type of addition.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/additions/{addition}")]
        public System.Threading.Tasks.Task<string> GetAddition([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string repository_name, string reference, Addition addition)
        {

            return _implementation.GetAdditionAsync(x_Request_Id, project_name, repository_name, reference, addition);
        }

        /// <summary>
        /// Add label to artifact
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>
        /// <param name="reference">The reference of the artifact, can be digest or tag</param>
        /// <param name="label">The label that added to the artifact. Only the ID property is needed.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/labels")]
        public System.Threading.Tasks.Task AddLabel([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string repository_name, string reference, [Microsoft.AspNetCore.Mvc.FromBody] Label label)
        {

            return _implementation.AddLabelAsync(x_Request_Id, project_name, repository_name, reference, label);
        }

        /// <summary>
        /// Remove label from artifact
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="repository_name">The name of the repository. If it contains slash, encode it with URL encoding. e.g. a/b -&gt; a%252Fb</param>
        /// <param name="reference">The reference of the artifact, can be digest or tag</param>
        /// <param name="label_id">The ID of the label that removed from the artifact.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/repositories/{repository_name}/artifacts/{reference}/labels/{label_id}")]
        public System.Threading.Tasks.Task RemoveLabel([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string repository_name, string reference, long label_id)
        {

            return _implementation.RemoveLabelAsync(x_Request_Id, project_name, repository_name, reference, label_id);
        }

        /// <summary>
        /// Get project level scanner
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <returns>The details of the scanner registration.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/scanner")]
        public System.Threading.Tasks.Task<ScannerRegistration> GetScannerOfProject([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id)
        {

            return _implementation.GetScannerOfProjectAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id);
        }

        /// <summary>
        /// Configure scanner for the specified project
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/scanner")]
        public System.Threading.Tasks.Task SetScannerOfProject([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, [Microsoft.AspNetCore.Mvc.FromBody] ProjectScanner payload)
        {

            return _implementation.SetScannerOfProjectAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, payload);
        }

        /// <summary>
        /// Get scanner registration candidates for configurating project level scanner
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <returns>A list of scanner registrations.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/scanner/candidates")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ScannerRegistration>> ListScannerCandidatesOfProject([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size)
        {

            return _implementation.ListScannerCandidatesOfProjectAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, q, sort, page ?? 1L, page_size ?? 10L);
        }

        /// <summary>
        /// Get recent logs of the projects which the user is a member of
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("audit-logs")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<AuditLog>> ListAuditLogs([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size)
        {

            return _implementation.ListAuditLogsAsync(x_Request_Id, q, sort, page ?? 1L, page_size ?? 10L);
        }

        /// <summary>
        /// Get recent logs of the projects
        /// </summary>
        /// <param name="project_name">The name of the project</param>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/logs")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<AuditLog>> GetLogs(string project_name, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size)
        {

            return _implementation.GetLogsAsync(project_name, x_Request_Id, q, sort, page ?? 1L, page_size ?? 10L);
        }

        /// <summary>
        /// List P2P providers
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("p2p/preheat/providers")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Metadata>> ListProviders([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id)
        {

            return _implementation.ListProvidersAsync(x_Request_Id);
        }

        /// <summary>
        /// Ping status of a instance.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="instance">The JSON object of instance.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("p2p/preheat/instances/ping")]
        public System.Threading.Tasks.Task PingInstances([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] Instance instance)
        {

            return _implementation.PingInstancesAsync(x_Request_Id, instance);
        }

        /// <summary>
        /// List P2P provider instances
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("p2p/preheat/instances")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Instance>> ListInstances([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort)
        {

            return _implementation.ListInstancesAsync(x_Request_Id, page ?? 1L, page_size ?? 10L, q, sort);
        }

        /// <summary>
        /// Create p2p provider instances
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="instance">The JSON object of instance.</param>
        /// <returns>Created</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("p2p/preheat/instances")]
        public System.Threading.Tasks.Task CreateInstance([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] Instance instance)
        {

            return _implementation.CreateInstanceAsync(x_Request_Id, instance);
        }

        /// <summary>
        /// Get a P2P provider instance
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="preheat_instance_name">Instance Name</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("p2p/preheat/instances/{preheat_instance_name}")]
        public System.Threading.Tasks.Task<Instance> GetInstance([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string preheat_instance_name)
        {

            return _implementation.GetInstanceAsync(x_Request_Id, preheat_instance_name);
        }

        /// <summary>
        /// Delete the specified P2P provider instance
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="preheat_instance_name">Instance Name</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("p2p/preheat/instances/{preheat_instance_name}")]
        public System.Threading.Tasks.Task DeleteInstance([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string preheat_instance_name)
        {

            return _implementation.DeleteInstanceAsync(x_Request_Id, preheat_instance_name);
        }

        /// <summary>
        /// Update the specified P2P provider instance
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="preheat_instance_name">Instance Name</param>
        /// <param name="instance">The instance to update</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("p2p/preheat/instances/{preheat_instance_name}")]
        public System.Threading.Tasks.Task UpdateInstance([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string preheat_instance_name, [Microsoft.AspNetCore.Mvc.FromBody] Instance instance)
        {

            return _implementation.UpdateInstanceAsync(x_Request_Id, preheat_instance_name, instance);
        }

        /// <summary>
        /// Create a preheat policy under a project
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="policy">The policy schema info</param>
        /// <returns>Created</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/preheat/policies")]
        public System.Threading.Tasks.Task CreatePolicy([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, [Microsoft.AspNetCore.Mvc.FromBody] PreheatPolicy policy)
        {

            return _implementation.CreatePolicyAsync(x_Request_Id, project_name, policy);
        }

        /// <summary>
        /// List preheat policies
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <returns>List preheat policies success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/preheat/policies")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<PreheatPolicy>> ListPolicies([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort)
        {

            return _implementation.ListPoliciesAsync(x_Request_Id, project_name, page ?? 1L, page_size ?? 10L, q, sort);
        }

        /// <summary>
        /// Get a preheat policy
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="preheat_policy_name">Preheat Policy Name</param>
        /// <returns>Get a preheat policy success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/preheat/policies/{preheat_policy_name}")]
        public System.Threading.Tasks.Task<PreheatPolicy> GetPolicy([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string preheat_policy_name)
        {

            return _implementation.GetPolicyAsync(x_Request_Id, project_name, preheat_policy_name);
        }

        /// <summary>
        /// Update preheat policy
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="preheat_policy_name">Preheat Policy Name</param>
        /// <param name="policy">The policy schema info</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/preheat/policies/{preheat_policy_name}")]
        public System.Threading.Tasks.Task UpdatePolicy([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string preheat_policy_name, [Microsoft.AspNetCore.Mvc.FromBody] PreheatPolicy policy)
        {

            return _implementation.UpdatePolicyAsync(x_Request_Id, project_name, preheat_policy_name, policy);
        }

        /// <summary>
        /// Manual preheat
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="preheat_policy_name">Preheat Policy Name</param>
        /// <param name="policy">The policy schema info</param>
        /// <returns>Created</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/preheat/policies/{preheat_policy_name}")]
        public System.Threading.Tasks.Task ManualPreheat([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string preheat_policy_name, [Microsoft.AspNetCore.Mvc.FromBody] PreheatPolicy policy)
        {

            return _implementation.ManualPreheatAsync(x_Request_Id, project_name, preheat_policy_name, policy);
        }

        /// <summary>
        /// Delete a preheat policy
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="preheat_policy_name">Preheat Policy Name</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/preheat/policies/{preheat_policy_name}")]
        public System.Threading.Tasks.Task DeletePolicy([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string preheat_policy_name)
        {

            return _implementation.DeletePolicyAsync(x_Request_Id, project_name, preheat_policy_name);
        }

        /// <summary>
        /// List executions for the given policy
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="preheat_policy_name">Preheat Policy Name</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <returns>List executions success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/preheat/policies/{preheat_policy_name}/executions")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Execution>> ListExecutions([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string preheat_policy_name, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort)
        {

            return _implementation.ListExecutionsAsync(x_Request_Id, project_name, preheat_policy_name, page ?? 1L, page_size ?? 10L, q, sort);
        }

        /// <summary>
        /// Get a execution detail by id
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="preheat_policy_name">Preheat Policy Name</param>
        /// <param name="execution_id">Execution ID</param>
        /// <returns>Get execution success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}")]
        public System.Threading.Tasks.Task<Execution> GetExecution([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string preheat_policy_name, int execution_id)
        {

            return _implementation.GetExecutionAsync(x_Request_Id, project_name, preheat_policy_name, execution_id);
        }

        /// <summary>
        /// Stop a execution
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="preheat_policy_name">Preheat Policy Name</param>
        /// <param name="execution_id">Execution ID</param>
        /// <param name="execution">The data of execution</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPatch, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}")]
        public System.Threading.Tasks.Task StopExecution([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string preheat_policy_name, int execution_id, [Microsoft.AspNetCore.Mvc.FromBody] Execution execution)
        {

            return _implementation.StopExecutionAsync(x_Request_Id, project_name, preheat_policy_name, execution_id, execution);
        }

        /// <summary>
        /// List all the related tasks for the given execution
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="preheat_policy_name">Preheat Policy Name</param>
        /// <param name="execution_id">Execution ID</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <returns>List tasks success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}/tasks")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Task>> ListTasks([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string preheat_policy_name, int execution_id, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort)
        {

            return _implementation.ListTasksAsync(x_Request_Id, project_name, preheat_policy_name, execution_id, page ?? 1L, page_size ?? 10L, q, sort);
        }

        /// <summary>
        /// Get the log text stream of the specified task for the given execution
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <param name="preheat_policy_name">Preheat Policy Name</param>
        /// <param name="execution_id">Execution ID</param>
        /// <param name="task_id">Task ID</param>
        /// <returns>Get log success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}/tasks/{task_id}/logs")]
        public System.Threading.Tasks.Task<string> GetPreheatLog([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name, string preheat_policy_name, int execution_id, int task_id)
        {

            return _implementation.GetPreheatLogAsync(x_Request_Id, project_name, preheat_policy_name, execution_id, task_id);
        }

        /// <summary>
        /// Get all providers at project level
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="project_name">The name of the project</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name}/preheat/providers")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ProviderUnderProject>> ListProvidersUnderProject([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string project_name)
        {

            return _implementation.ListProvidersUnderProjectAsync(x_Request_Id, project_name);
        }

        /// <summary>
        /// Get all robot accounts of specified project
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/robots")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Robot>> ListRobotV1([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort)
        {

            return _implementation.ListRobotV1Async(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, page ?? 1L, page_size ?? 10L, q, sort);
        }

        /// <summary>
        /// Create a robot account
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="robot">The JSON object of a robot account.</param>
        /// <returns>Created</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/robots")]
        public System.Threading.Tasks.Task<RobotCreated> CreateRobotV1([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, [Microsoft.AspNetCore.Mvc.FromBody] RobotCreateV1 robot)
        {

            return _implementation.CreateRobotV1Async(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, robot);
        }

        /// <summary>
        /// Get a robot account
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="robot_id">Robot ID</param>
        /// <returns>Return matched robot information.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/robots/{robot_id}")]
        public System.Threading.Tasks.Task<Robot> GetRobotByIDV1([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, int robot_id)
        {

            return _implementation.GetRobotByIDV1Async(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, robot_id);
        }

        /// <summary>
        /// Update status of robot account.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="robot_id">Robot ID</param>
        /// <param name="robot">The JSON object of a robot account.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/robots/{robot_id}")]
        public System.Threading.Tasks.Task UpdateRobotV1([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, int robot_id, [Microsoft.AspNetCore.Mvc.FromBody] Robot robot)
        {

            return _implementation.UpdateRobotV1Async(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, robot_id, robot);
        }

        /// <summary>
        /// Delete a robot account
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="robot_id">Robot ID</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/robots/{robot_id}")]
        public System.Threading.Tasks.Task DeleteRobotV1([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, int robot_id)
        {

            return _implementation.DeleteRobotV1Async(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, robot_id);
        }

        /// <summary>
        /// List all immutable tag rules of current project
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/immutabletagrules")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ImmutableRule>> ListImmuRules([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort)
        {

            return _implementation.ListImmuRulesAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, page ?? 1L, page_size ?? 10L, q, sort);
        }

        /// <summary>
        /// Add an immutable tag rule to current project
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <returns>Created</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/immutabletagrules")]
        public System.Threading.Tasks.Task CreateImmuRule([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, [Microsoft.AspNetCore.Mvc.FromBody] ImmutableRule immutableRule)
        {

            return _implementation.CreateImmuRuleAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, immutableRule);
        }

        /// <summary>
        /// Update the immutable tag rule or enable or disable the rule
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="immutable_rule_id">The ID of the immutable rule</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/immutabletagrules/{immutable_rule_id}")]
        public System.Threading.Tasks.Task UpdateImmuRule([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, long immutable_rule_id, [Microsoft.AspNetCore.Mvc.FromBody] ImmutableRule immutableRule)
        {

            return _implementation.UpdateImmuRuleAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, immutable_rule_id, immutableRule);
        }

        /// <summary>
        /// Delete the immutable tag rule.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="immutable_rule_id">The ID of the immutable rule</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/immutabletagrules/{immutable_rule_id}")]
        public System.Threading.Tasks.Task DeleteImmuRule([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, long immutable_rule_id)
        {

            return _implementation.DeleteImmuRuleAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, immutable_rule_id);
        }

        /// <summary>
        /// List project webhook policies.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/webhook/policies")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<WebhookPolicy>> ListWebhookPoliciesOfProject([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, [Microsoft.AspNetCore.Mvc.FromQuery] string sort, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size)
        {

            return _implementation.ListWebhookPoliciesOfProjectAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, sort, q, page ?? 1L, page_size ?? 10L);
        }

        /// <summary>
        /// Create project webhook policy.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="policy">Properties "targets" and "event_types" needed.</param>
        /// <returns>Project webhook policy create successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/webhook/policies")]
        public System.Threading.Tasks.Task CreateWebhookPolicyOfProject([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, [Microsoft.AspNetCore.Mvc.FromBody] WebhookPolicy policy)
        {

            return _implementation.CreateWebhookPolicyOfProjectAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, policy);
        }

        /// <summary>
        /// Get project webhook policy
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="webhook_policy_id">The ID of the webhook policy</param>
        /// <returns>Get webhook policy successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/webhook/policies/{webhook_policy_id}")]
        public System.Threading.Tasks.Task<WebhookPolicy> GetWebhookPolicyOfProject([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, long webhook_policy_id)
        {

            return _implementation.GetWebhookPolicyOfProjectAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, webhook_policy_id);
        }

        /// <summary>
        /// Update webhook policy of a project.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="webhook_policy_id">The ID of the webhook policy</param>
        /// <param name="policy">All properties needed except "id", "project_id", "creation_time", "update_time".</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/webhook/policies/{webhook_policy_id}")]
        public System.Threading.Tasks.Task UpdateWebhookPolicyOfProject([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, long webhook_policy_id, [Microsoft.AspNetCore.Mvc.FromBody] WebhookPolicy policy)
        {

            return _implementation.UpdateWebhookPolicyOfProjectAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, webhook_policy_id, policy);
        }

        /// <summary>
        /// Delete webhook policy of a project
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="webhook_policy_id">The ID of the webhook policy</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/webhook/policies/{webhook_policy_id}")]
        public System.Threading.Tasks.Task DeleteWebhookPolicyOfProject([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, long webhook_policy_id)
        {

            return _implementation.DeleteWebhookPolicyOfProjectAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, webhook_policy_id);
        }

        /// <summary>
        /// Get project webhook policy last trigger info
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <returns>Test webhook connection successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/webhook/lasttrigger")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<WebhookLastTrigger>> LastTrigger([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id)
        {

            return _implementation.LastTriggerAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id);
        }

        /// <summary>
        /// List project webhook jobs
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <param name="policy_id">The policy ID.</param>
        /// <param name="status">The status of webhook job.</param>
        /// <returns>List project webhook jobs successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/webhook/jobs")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<WebhookJob>> ListWebhookJobs([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size, [Microsoft.AspNetCore.Mvc.FromQuery] long policy_id, [Microsoft.AspNetCore.Mvc.FromQuery] System.Collections.Generic.IEnumerable<string> status)
        {

            return _implementation.ListWebhookJobsAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id, q, sort, page ?? 1L, page_size ?? 10L, policy_id, status);
        }

        /// <summary>
        /// Get supported event types and notify types.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Is_Resource_Name">The flag to indicate whether the parameter which supports both name and id in the path is the name of the resource. When the X-Is-Resource-Name is false and the parameter can be converted to an integer, the parameter will be as an id, otherwise, it will be as a name.</param>
        /// <param name="project_name_or_id">The name or id of the project</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("projects/{project_name_or_id}/webhook/events")]
        public System.Threading.Tasks.Task<SupportedWebhookEventTypes> GetSupportedEventTypes([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Is-Resource-Name")] bool? x_Is_Resource_Name, string project_name_or_id)
        {

            return _implementation.GetSupportedEventTypesAsync(x_Request_Id, x_Is_Resource_Name ?? false, project_name_or_id);
        }

        /// <summary>
        /// Get all user groups information
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <param name="ldap_group_dn">search with ldap group DN</param>
        /// <param name="group_name">group name need to search, fuzzy matches</param>
        /// <returns>Get user group successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("usergroups")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<UserGroup>> ListUserGroups([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size, [Microsoft.AspNetCore.Mvc.FromQuery] string ldap_group_dn, [Microsoft.AspNetCore.Mvc.FromQuery] string group_name)
        {

            return _implementation.ListUserGroupsAsync(x_Request_Id, page ?? 1L, page_size ?? 10L, ldap_group_dn, group_name);
        }

        /// <summary>
        /// Create user group
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>User group created successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("usergroups")]
        public System.Threading.Tasks.Task CreateUserGroup([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] UserGroup usergroup)
        {

            return _implementation.CreateUserGroupAsync(x_Request_Id, usergroup);
        }

        /// <summary>
        /// Search groups by groupname
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <param name="groupname">Group name for filtering results.</param>
        /// <returns>Search groups successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("usergroups/search")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<UserGroupSearchItem>> SearchUserGroups([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size, [Microsoft.AspNetCore.Mvc.FromQuery] string groupname)
        {

            return _implementation.SearchUserGroupsAsync(x_Request_Id, page ?? 1L, page_size ?? 10L, groupname);
        }

        /// <summary>
        /// Get user group information
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="group_id">Group ID</param>
        /// <returns>User group get successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("usergroups/{group_id}")]
        public System.Threading.Tasks.Task<UserGroup> GetUserGroup([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long group_id)
        {

            return _implementation.GetUserGroupAsync(x_Request_Id, group_id);
        }

        /// <summary>
        /// Update group information
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="group_id">Group ID</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("usergroups/{group_id}")]
        public System.Threading.Tasks.Task UpdateUserGroup([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long group_id, [Microsoft.AspNetCore.Mvc.FromBody] UserGroup usergroup)
        {

            return _implementation.UpdateUserGroupAsync(x_Request_Id, group_id, usergroup);
        }

        /// <summary>
        /// Delete user group
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("usergroups/{group_id}")]
        public System.Threading.Tasks.Task DeleteUserGroup([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, int group_id)
        {

            return _implementation.DeleteUserGroupAsync(x_Request_Id, group_id);
        }

        /// <summary>
        /// Get artifact icon
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="digest">The digest of the resource</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("icons/{digest}")]
        public System.Threading.Tasks.Task<Icon> GetIcon([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string digest)
        {

            return _implementation.GetIconAsync(x_Request_Id, digest);
        }

        /// <summary>
        /// Get robot account
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("robots")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Robot>> ListRobot([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size)
        {

            return _implementation.ListRobotAsync(x_Request_Id, q, sort, page ?? 1L, page_size ?? 10L);
        }

        /// <summary>
        /// Create a robot account
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="robot">The JSON object of a robot account.</param>
        /// <returns>Created</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("robots")]
        public System.Threading.Tasks.Task<RobotCreated> CreateRobot([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] RobotCreate robot)
        {

            return _implementation.CreateRobotAsync(x_Request_Id, robot);
        }

        /// <summary>
        /// List quotas
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <param name="reference">The reference type of quota.</param>
        /// <param name="reference_id">The reference id of quota.</param>
        /// <param name="sort">Sort method, valid values include:
        /// <br/>'hard.resource_name', '-hard.resource_name', 'used.resource_name', '-used.resource_name'.
        /// <br/>Here '-' stands for descending order, resource_name should be the real resource name of the quota.</param>
        /// <returns>Successfully retrieved the quotas.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("quotas")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Quota>> ListQuotas([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size, [Microsoft.AspNetCore.Mvc.FromQuery] string reference, [Microsoft.AspNetCore.Mvc.FromQuery] string reference_id, [Microsoft.AspNetCore.Mvc.FromQuery] string sort)
        {

            return _implementation.ListQuotasAsync(x_Request_Id, page ?? 1L, page_size ?? 10L, reference, reference_id, sort);
        }

        /// <summary>
        /// Get the specified quota
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="id">Quota ID</param>
        /// <returns>Successfully retrieved the quota.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("quotas/{id}")]
        public System.Threading.Tasks.Task<Quota> GetQuota([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, int id)
        {

            return _implementation.GetQuotaAsync(x_Request_Id, id);
        }

        /// <summary>
        /// Update the specified quota
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="id">Quota ID</param>
        /// <param name="hard">The new hard limits for the quota</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("quotas/{id}")]
        public System.Threading.Tasks.Task UpdateQuota([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, int id, [Microsoft.AspNetCore.Mvc.FromBody] QuotaUpdateReq hard)
        {

            return _implementation.UpdateQuotaAsync(x_Request_Id, id, hard);
        }

        /// <summary>
        /// Get a robot account
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="robot_id">Robot ID</param>
        /// <returns>Return matched robot information.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("robots/{robot_id}")]
        public System.Threading.Tasks.Task<Robot> GetRobotByID([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, int robot_id)
        {

            return _implementation.GetRobotByIDAsync(x_Request_Id, robot_id);
        }

        /// <summary>
        /// Update a robot account
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="robot_id">Robot ID</param>
        /// <param name="robot">The JSON object of a robot account.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("robots/{robot_id}")]
        public System.Threading.Tasks.Task UpdateRobot([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, int robot_id, [Microsoft.AspNetCore.Mvc.FromBody] Robot robot)
        {

            return _implementation.UpdateRobotAsync(x_Request_Id, robot_id, robot);
        }

        /// <summary>
        /// Refresh the robot secret
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="robot_id">Robot ID</param>
        /// <param name="robotSec">The JSON object of a robot account.</param>
        /// <returns>Return refreshed robot sec.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPatch, Microsoft.AspNetCore.Mvc.Route("robots/{robot_id}")]
        public System.Threading.Tasks.Task<RobotSec> RefreshSec([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, int robot_id, [Microsoft.AspNetCore.Mvc.FromBody] RobotSec robotSec)
        {

            return _implementation.RefreshSecAsync(x_Request_Id, robot_id, robotSec);
        }

        /// <summary>
        /// Delete a robot account
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="robot_id">Robot ID</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("robots/{robot_id}")]
        public System.Threading.Tasks.Task DeleteRobot([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, int robot_id)
        {

            return _implementation.DeleteRobotAsync(x_Request_Id, robot_id);
        }

        /// <summary>
        /// List replication policies
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <param name="name">Deprecated, use "query" instead. The policy name.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("replication/policies")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ReplicationPolicy>> ListReplicationPolicies([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size, [Microsoft.AspNetCore.Mvc.FromQuery] string name)
        {

            return _implementation.ListReplicationPoliciesAsync(x_Request_Id, q, sort, page ?? 1L, page_size ?? 10L, name);
        }

        /// <summary>
        /// Create a replication policy
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="policy">The replication policy</param>
        /// <returns>Created</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("replication/policies")]
        public System.Threading.Tasks.Task CreateReplicationPolicy([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] ReplicationPolicy policy)
        {

            return _implementation.CreateReplicationPolicyAsync(x_Request_Id, policy);
        }

        /// <summary>
        /// Get the specific replication policy
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="id">Policy ID</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("replication/policies/{id}")]
        public System.Threading.Tasks.Task<ReplicationPolicy> GetReplicationPolicy([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long id)
        {

            return _implementation.GetReplicationPolicyAsync(x_Request_Id, id);
        }

        /// <summary>
        /// Delete the specific replication policy
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="id">Replication policy ID</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("replication/policies/{id}")]
        public System.Threading.Tasks.Task DeleteReplicationPolicy([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long id)
        {

            return _implementation.DeleteReplicationPolicyAsync(x_Request_Id, id);
        }

        /// <summary>
        /// Update the replication policy
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="id">The policy ID</param>
        /// <param name="policy">The replication policy</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("replication/policies/{id}")]
        public System.Threading.Tasks.Task UpdateReplicationPolicy([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long id, [Microsoft.AspNetCore.Mvc.FromBody] ReplicationPolicy policy)
        {

            return _implementation.UpdateReplicationPolicyAsync(x_Request_Id, id, policy);
        }

        /// <summary>
        /// List replication executions
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <param name="policy_id">The ID of the policy that the executions belong to.</param>
        /// <param name="status">The execution status.</param>
        /// <param name="trigger">The trigger mode.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("replication/executions")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ReplicationExecution>> ListReplicationExecutions([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] string sort, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size, [Microsoft.AspNetCore.Mvc.FromQuery] int? policy_id, [Microsoft.AspNetCore.Mvc.FromQuery] string status, [Microsoft.AspNetCore.Mvc.FromQuery] string trigger)
        {

            return _implementation.ListReplicationExecutionsAsync(x_Request_Id, sort, page ?? 1L, page_size ?? 10L, policy_id, status, trigger);
        }

        /// <summary>
        /// Start one replication execution
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="execution">The ID of policy that the execution belongs to</param>
        /// <returns>Created</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("replication/executions")]
        public System.Threading.Tasks.Task StartReplication([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] StartReplicationExecution execution)
        {

            return _implementation.StartReplicationAsync(x_Request_Id, execution);
        }

        /// <summary>
        /// Get the specific replication execution
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="id">The ID of the execution.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("replication/executions/{id}")]
        public System.Threading.Tasks.Task<ReplicationExecution> GetReplicationExecution([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long id)
        {

            return _implementation.GetReplicationExecutionAsync(x_Request_Id, id);
        }

        /// <summary>
        /// Stop the specific replication execution
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="id">The ID of the execution.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("replication/executions/{id}")]
        public System.Threading.Tasks.Task StopReplication([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long id)
        {

            return _implementation.StopReplicationAsync(x_Request_Id, id);
        }

        /// <summary>
        /// List replication tasks for a specific execution
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <param name="id">The ID of the execution that the tasks belongs to.</param>
        /// <param name="status">The task status.</param>
        /// <param name="resource_type">The resource type.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("replication/executions/{id}/tasks")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ReplicationTask>> ListReplicationTasks([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] string sort, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size, long id, [Microsoft.AspNetCore.Mvc.FromQuery] string status, [Microsoft.AspNetCore.Mvc.FromQuery] string resource_type)
        {

            return _implementation.ListReplicationTasksAsync(x_Request_Id, sort, page ?? 1L, page_size ?? 10L, id, status, resource_type);
        }

        /// <summary>
        /// Get the log of the specific replication task
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="id">The ID of the execution that the tasks belongs to.</param>
        /// <param name="task_id">The ID of the task.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("replication/executions/{id}/tasks/{task_id}/log")]
        public System.Threading.Tasks.Task<string> GetReplicationLog([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long id, long task_id)
        {

            return _implementation.GetReplicationLogAsync(x_Request_Id, id, task_id);
        }

        /// <summary>
        /// List registry adapters
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>Success.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("replication/adapters")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<string>> ListRegistryProviderTypes([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id)
        {

            return _implementation.ListRegistryProviderTypesAsync(x_Request_Id);
        }

        /// <summary>
        /// List all registered registry provider information
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>Success.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("replication/adapterinfos")]
        public System.Threading.Tasks.Task<System.Collections.Generic.IDictionary<string, RegistryProviderInfo>> ListRegistryProviderInfos([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id)
        {

            return _implementation.ListRegistryProviderInfosAsync(x_Request_Id);
        }

        /// <summary>
        /// Create a registry
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="registry">The registry</param>
        /// <returns>Created</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("registries")]
        public System.Threading.Tasks.Task CreateRegistry([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] Registry registry)
        {

            return _implementation.CreateRegistryAsync(x_Request_Id, registry);
        }

        /// <summary>
        /// List the registries
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <param name="name">Deprecated, use `q` instead.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("registries")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Registry>> ListRegistries([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size, [Microsoft.AspNetCore.Mvc.FromQuery] string name)
        {

            return _implementation.ListRegistriesAsync(x_Request_Id, q, sort, page ?? 1L, page_size ?? 10L, name);
        }

        /// <summary>
        /// Check status of a registry
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="registry">The registry</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("registries/ping")]
        public System.Threading.Tasks.Task PingRegistry([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] RegistryPing registry)
        {

            return _implementation.PingRegistryAsync(x_Request_Id, registry);
        }

        /// <summary>
        /// Get the specific registry
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="id">Registry ID</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("registries/{id}")]
        public System.Threading.Tasks.Task<Registry> GetRegistry([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long id)
        {

            return _implementation.GetRegistryAsync(x_Request_Id, id);
        }

        /// <summary>
        /// Delete the specific registry
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="id">Registry ID</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("registries/{id}")]
        public System.Threading.Tasks.Task DeleteRegistry([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long id)
        {

            return _implementation.DeleteRegistryAsync(x_Request_Id, id);
        }

        /// <summary>
        /// Update the registry
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="id">The registry ID</param>
        /// <param name="registry">The registry</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("registries/{id}")]
        public System.Threading.Tasks.Task UpdateRegistry([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long id, [Microsoft.AspNetCore.Mvc.FromBody] RegistryUpdate registry)
        {

            return _implementation.UpdateRegistryAsync(x_Request_Id, id, registry);
        }

        /// <summary>
        /// Get the registry info
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="id">Registry ID</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("registries/{id}/info")]
        public System.Threading.Tasks.Task<RegistryInfo> GetRegistryInfo([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long id)
        {

            return _implementation.GetRegistryInfoAsync(x_Request_Id, id);
        }

        /// <summary>
        /// Get the metrics of the latest scan all process
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>OK</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("scans/all/metrics")]
        public System.Threading.Tasks.Task<Stats> GetLatestScanAllMetrics([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id)
        {

            return _implementation.GetLatestScanAllMetricsAsync(x_Request_Id);
        }

        /// <summary>
        /// Get the metrics of the latest scheduled scan all process
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>OK</returns>
        [System.Obsolete]
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("scans/schedule/metrics")]
        public System.Threading.Tasks.Task<Stats> GetLatestScheduledScanAllMetrics([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id)
        {

            return _implementation.GetLatestScheduledScanAllMetricsAsync(x_Request_Id);
        }

        /// <summary>
        /// Get general system info
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>Get general info successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("systeminfo")]
        public System.Threading.Tasks.Task<GeneralInfo> GetSystemInfo([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id)
        {

            return _implementation.GetSystemInfoAsync(x_Request_Id);
        }

        /// <summary>
        /// Get system volume info (total/free size).
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>Get system volumes successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("systeminfo/volumes")]
        public System.Threading.Tasks.Task<SystemInfo> GetVolumes([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id)
        {

            return _implementation.GetVolumesAsync(x_Request_Id);
        }

        /// <summary>
        /// Get default root certificate.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>Get default root certificate successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("systeminfo/getcert")]
        public System.Threading.Tasks.Task<FileResult> GetCert([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id)
        {

            return _implementation.GetCertAsync(x_Request_Id);
        }

        /// <summary>
        /// Test the OIDC endpoint.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="endpoint">Request body for OIDC endpoint to be tested.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("system/oidc/ping")]
        public System.Threading.Tasks.Task PingOIDC([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] Endpoint endpoint)
        {

            return _implementation.PingOIDCAsync(x_Request_Id, endpoint);
        }

        /// <summary>
        /// Get gc results.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <returns>Get gc results successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("system/gc")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<GCHistory>> GetGCHistory([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size)
        {

            return _implementation.GetGCHistoryAsync(x_Request_Id, q, sort, page ?? 1L, page_size ?? 10L);
        }

        /// <summary>
        /// Get gc status.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="gc_id">The ID of the gc log</param>
        /// <returns>Get gc results successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("system/gc/{gc_id}")]
        public System.Threading.Tasks.Task<GCHistory> GetGC([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long gc_id)
        {

            return _implementation.GetGCAsync(x_Request_Id, gc_id);
        }

        /// <summary>
        /// Stop the specific GC execution
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="gc_id">The ID of the gc log</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("system/gc/{gc_id}")]
        public System.Threading.Tasks.Task StopGC([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long gc_id)
        {

            return _implementation.StopGCAsync(x_Request_Id, gc_id);
        }

        /// <summary>
        /// Get gc job log.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="gc_id">The ID of the gc log</param>
        /// <returns>Get successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("system/gc/{gc_id}/log")]
        public System.Threading.Tasks.Task<string> GetGCLog([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long gc_id)
        {

            return _implementation.GetGCLogAsync(x_Request_Id, gc_id);
        }

        /// <summary>
        /// Get gc's schedule.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>Get gc's schedule.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("system/gc/schedule")]
        public System.Threading.Tasks.Task<GCHistory> GetGCSchedule([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id)
        {

            return _implementation.GetGCScheduleAsync(x_Request_Id);
        }

        /// <summary>
        /// Create a gc schedule.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="schedule">Updates of gc's schedule.</param>
        /// <returns>Created</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("system/gc/schedule")]
        public System.Threading.Tasks.Task CreateGCSchedule([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] Schedule schedule)
        {

            return _implementation.CreateGCScheduleAsync(x_Request_Id, schedule);
        }

        /// <summary>
        /// Update gc's schedule.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="schedule">Updates of gc's schedule.</param>
        /// <returns>Updated gc's schedule successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("system/gc/schedule")]
        public System.Threading.Tasks.Task UpdateGCSchedule([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] Schedule schedule)
        {

            return _implementation.UpdateGCScheduleAsync(x_Request_Id, schedule);
        }

        /// <summary>
        /// Get purge job results.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <returns>Get purge job results successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("system/purgeaudit")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ExecHistory>> GetPurgeHistory([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size)
        {

            return _implementation.GetPurgeHistoryAsync(x_Request_Id, q, sort, page ?? 1L, page_size ?? 10L);
        }

        /// <summary>
        /// Get purge job status.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="purge_id">The ID of the purge log</param>
        /// <returns>Get purge job results successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("system/purgeaudit/{purge_id}")]
        public System.Threading.Tasks.Task<ExecHistory> GetPurgeJob([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long purge_id)
        {

            return _implementation.GetPurgeJobAsync(x_Request_Id, purge_id);
        }

        /// <summary>
        /// Stop the specific purge audit log execution
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="purge_id">The ID of the purge log</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("system/purgeaudit/{purge_id}")]
        public System.Threading.Tasks.Task StopPurge([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long purge_id)
        {

            return _implementation.StopPurgeAsync(x_Request_Id, purge_id);
        }

        /// <summary>
        /// Get purge job log.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="purge_id">The ID of the purge log</param>
        /// <returns>Get successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("system/purgeaudit/{purge_id}/log")]
        public System.Threading.Tasks.Task<string> GetPurgeJobLog([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long purge_id)
        {

            return _implementation.GetPurgeJobLogAsync(x_Request_Id, purge_id);
        }

        /// <summary>
        /// Get purge's schedule.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>Get purge job's schedule.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("system/purgeaudit/schedule")]
        public System.Threading.Tasks.Task<ExecHistory> GetPurgeSchedule([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id)
        {

            return _implementation.GetPurgeScheduleAsync(x_Request_Id);
        }

        /// <summary>
        /// Create a purge job schedule.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="schedule">The purge job's schedule, it is a json object. ｜
        /// <br/>The sample format is ｜
        /// <br/>{"parameters":{"audit_retention_hour":168,"dry_run":true, "include_operations":"create,delete,pull"},"schedule":{"type":"Hourly","cron":"0 0 * * * *"}} ｜
        /// <br/>the include_operation should be a comma separated string, e.g. create,delete,pull, if it is empty, no operation will be purged.</param>
        /// <returns>Created</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("system/purgeaudit/schedule")]
        public System.Threading.Tasks.Task CreatePurgeSchedule([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] Schedule schedule)
        {

            return _implementation.CreatePurgeScheduleAsync(x_Request_Id, schedule);
        }

        /// <summary>
        /// Update purge job's schedule.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="schedule">The purge job's schedule, it is a json object. ｜
        /// <br/>The sample format is ｜
        /// <br/>{"parameters":{"audit_retention_hour":168,"dry_run":true, "include_operations":"create,delete,pull"},"schedule":{"type":"Hourly","cron":"0 0 * * * *"}} ｜
        /// <br/>the include_operation should be a comma separated string, e.g. create,delete,pull, if it is empty, no operation will be purged.</param>
        /// <returns>Updated purge's schedule successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("system/purgeaudit/schedule")]
        public System.Threading.Tasks.Task UpdatePurgeSchedule([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] Schedule schedule)
        {

            return _implementation.UpdatePurgeScheduleAsync(x_Request_Id, schedule);
        }

        /// <summary>
        /// Get the system level allowlist of CVE.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>Successfully retrieved the CVE allowlist.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("system/CVEAllowlist")]
        public System.Threading.Tasks.Task<CVEAllowlist> GetSystemCVEAllowlist([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id)
        {

            return _implementation.GetSystemCVEAllowlistAsync(x_Request_Id);
        }

        /// <summary>
        /// Update the system level allowlist of CVE.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="allowlist">The allowlist with new content</param>
        /// <returns>Successfully updated the CVE allowlist.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("system/CVEAllowlist")]
        public System.Threading.Tasks.Task PutSystemCVEAllowlist([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] CVEAllowlist allowlist)
        {

            return _implementation.PutSystemCVEAllowlistAsync(x_Request_Id, allowlist);
        }

        /// <summary>
        /// Get scan all's schedule.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>Get a schedule for the scan all job, which scans all of images in Harbor.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("system/scanAll/schedule")]
        public System.Threading.Tasks.Task<Schedule> GetScanAllSchedule([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id)
        {

            return _implementation.GetScanAllScheduleAsync(x_Request_Id);
        }

        /// <summary>
        /// Update scan all's schedule.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="schedule">Updates the schedule of scan all job, which scans all of images in Harbor.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("system/scanAll/schedule")]
        public System.Threading.Tasks.Task UpdateScanAllSchedule([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] Schedule schedule)
        {

            return _implementation.UpdateScanAllScheduleAsync(x_Request_Id, schedule);
        }

        /// <summary>
        /// Create a schedule or a manual trigger for the scan all job.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="schedule">Create a schedule or a manual trigger for the scan all job.</param>
        /// <returns>Created</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("system/scanAll/schedule")]
        public System.Threading.Tasks.Task CreateScanAllSchedule([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] Schedule schedule)
        {

            return _implementation.CreateScanAllScheduleAsync(x_Request_Id, schedule);
        }

        /// <summary>
        /// Stop scanAll job execution
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>Accepted</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("system/scanAll/stop")]
        public System.Threading.Tasks.Task StopScanAll([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id)
        {

            return _implementation.StopScanAllAsync(x_Request_Id);
        }

        /// <summary>
        /// Ping Harbor to check if it's alive.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>The API server is alive</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("ping")]
        public System.Threading.Tasks.Task<string> GetPing([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id)
        {

            return _implementation.GetPingAsync(x_Request_Id);
        }

        /// <summary>
        /// Get Retention Metadatas
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>Get Retention Metadatas successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("retentions/metadatas")]
        public System.Threading.Tasks.Task<RetentionMetadata> GetRentenitionMetadata([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id)
        {

            return _implementation.GetRentenitionMetadataAsync(x_Request_Id);
        }

        /// <summary>
        /// Create Retention Policy
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="policy">Create Retention Policy successfully.</param>
        /// <returns>Created</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("retentions")]
        public System.Threading.Tasks.Task CreateRetention([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] RetentionPolicy policy)
        {

            return _implementation.CreateRetentionAsync(x_Request_Id, policy);
        }

        /// <summary>
        /// Get Retention Policy
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="id">Retention ID.</param>
        /// <returns>Get Retention Policy successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("retentions/{id}")]
        public System.Threading.Tasks.Task<RetentionPolicy> GetRetention([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long id)
        {

            return _implementation.GetRetentionAsync(x_Request_Id, id);
        }

        /// <summary>
        /// Update Retention Policy
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="id">Retention ID.</param>
        /// <returns>Update Retention Policy successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("retentions/{id}")]
        public System.Threading.Tasks.Task UpdateRetention([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long id, [Microsoft.AspNetCore.Mvc.FromBody] RetentionPolicy policy)
        {

            return _implementation.UpdateRetentionAsync(x_Request_Id, id, policy);
        }

        /// <summary>
        /// Delete Retention Policy
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="id">Retention ID.</param>
        /// <returns>Update Retention Policy successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("retentions/{id}")]
        public System.Threading.Tasks.Task DeleteRetention([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long id)
        {

            return _implementation.DeleteRetentionAsync(x_Request_Id, id);
        }

        /// <summary>
        /// Trigger a Retention Execution
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="id">Retention ID.</param>
        /// <returns>Trigger a Retention job successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("retentions/{id}/executions")]
        public System.Threading.Tasks.Task TriggerRetentionExecution([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long id, [Microsoft.AspNetCore.Mvc.FromBody] Body body)
        {

            return _implementation.TriggerRetentionExecutionAsync(x_Request_Id, id, body);
        }

        /// <summary>
        /// Get Retention executions
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="id">Retention ID.</param>
        /// <param name="page">The page number.</param>
        /// <param name="page_size">The size of per page.</param>
        /// <returns>Get a Retention execution successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("retentions/{id}/executions")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RetentionExecution>> ListRetentionExecutions([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long id, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size)
        {

            return _implementation.ListRetentionExecutionsAsync(x_Request_Id, id, page, page_size);
        }

        /// <summary>
        /// Stop a Retention execution
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="id">Retention ID.</param>
        /// <param name="eid">Retention execution ID.</param>
        /// <param name="body">The action, only support "stop" now.</param>
        /// <returns>Stop a Retention job successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPatch, Microsoft.AspNetCore.Mvc.Route("retentions/{id}/executions/{eid}")]
        public System.Threading.Tasks.Task OperateRetentionExecution([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long id, long eid, [Microsoft.AspNetCore.Mvc.FromBody] Body2 body)
        {

            return _implementation.OperateRetentionExecutionAsync(x_Request_Id, id, eid, body);
        }

        /// <summary>
        /// Get Retention tasks
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="id">Retention ID.</param>
        /// <param name="eid">Retention execution ID.</param>
        /// <param name="page">The page number.</param>
        /// <param name="page_size">The size of per page.</param>
        /// <returns>Get Retention job tasks successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("retentions/{id}/executions/{eid}/tasks")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<RetentionExecutionTask>> ListRetentionTasks([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long id, long eid, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size)
        {

            return _implementation.ListRetentionTasksAsync(x_Request_Id, id, eid, page, page_size);
        }

        /// <summary>
        /// Get Retention job task log
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="id">Retention ID.</param>
        /// <param name="eid">Retention execution ID.</param>
        /// <param name="tid">Retention execution ID.</param>
        /// <returns>Get Retention job task log successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("retentions/{id}/executions/{eid}/tasks/{tid}")]
        public System.Threading.Tasks.Task<string> GetRetentionTaskLog([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long id, long eid, long tid)
        {

            return _implementation.GetRetentionTaskLogAsync(x_Request_Id, id, eid, tid);
        }

        /// <summary>
        /// List scanner registrations
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <returns>A list of scanner registrations.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("scanners")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ScannerRegistration>> ListScanners([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size)
        {

            return _implementation.ListScannersAsync(x_Request_Id, q, sort, page ?? 1L, page_size ?? 10L);
        }

        /// <summary>
        /// Create a scanner registration
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="registration">A scanner registration to be created.</param>
        /// <returns>Created successfully</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("scanners")]
        public System.Threading.Tasks.Task CreateScanner([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] ScannerRegistrationReq registration)
        {

            return _implementation.CreateScannerAsync(x_Request_Id, registration);
        }

        /// <summary>
        /// Tests scanner registration settings
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="settings">A scanner registration settings to be tested.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("scanners/ping")]
        public System.Threading.Tasks.Task PingScanner([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] ScannerRegistrationSettings settings)
        {

            return _implementation.PingScannerAsync(x_Request_Id, settings);
        }

        /// <summary>
        /// Get a scanner registration details
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="registration_id">The scanner registration identifer.</param>
        /// <returns>The details of the scanner registration.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("scanners/{registration_id}")]
        public System.Threading.Tasks.Task<ScannerRegistration> GetScanner([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string registration_id)
        {

            return _implementation.GetScannerAsync(x_Request_Id, registration_id);
        }

        /// <summary>
        /// Update a scanner registration
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="registration_id">The scanner registration identifier.</param>
        /// <param name="registration">A scanner registraiton to be updated.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("scanners/{registration_id}")]
        public System.Threading.Tasks.Task UpdateScanner([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string registration_id, [Microsoft.AspNetCore.Mvc.FromBody] ScannerRegistrationReq registration)
        {

            return _implementation.UpdateScannerAsync(x_Request_Id, registration_id, registration);
        }

        /// <summary>
        /// Delete a scanner registration
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="registration_id">The scanner registration identifier.</param>
        /// <returns>Deleted successfully and return the deleted registration</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("scanners/{registration_id}")]
        public System.Threading.Tasks.Task<ScannerRegistration> DeleteScanner([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string registration_id)
        {

            return _implementation.DeleteScannerAsync(x_Request_Id, registration_id);
        }

        /// <summary>
        /// Set system default scanner registration
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="registration_id">The scanner registration identifier.</param>
        /// <returns>Successfully set the specified scanner registration as system default</returns>
        [Microsoft.AspNetCore.Mvc.HttpPatch, Microsoft.AspNetCore.Mvc.Route("scanners/{registration_id}")]
        public System.Threading.Tasks.Task SetScannerAsDefault([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string registration_id, [Microsoft.AspNetCore.Mvc.FromBody] IsDefault payload)
        {

            return _implementation.SetScannerAsDefaultAsync(x_Request_Id, registration_id, payload);
        }

        /// <summary>
        /// Get the metadata of the specified scanner registration
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="registration_id">The scanner registration identifier.</param>
        /// <returns>The metadata of the specified scanner adapter</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("scanners/{registration_id}/metadata")]
        public System.Threading.Tasks.Task<ScannerAdapterMetadata> GetScannerMetadata([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, string registration_id)
        {

            return _implementation.GetScannerMetadataAsync(x_Request_Id, registration_id);
        }

        /// <summary>
        /// List users
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <returns>return the list of users.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("users")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<UserResp>> ListUsers([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size)
        {

            return _implementation.ListUsersAsync(x_Request_Id, q, sort, page ?? 1L, page_size ?? 10L);
        }

        /// <summary>
        /// Create a local user.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="userReq">The new user</param>
        /// <returns>Created</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("users")]
        public System.Threading.Tasks.Task CreateUser([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] UserCreationReq userReq)
        {

            return _implementation.CreateUserAsync(x_Request_Id, userReq);
        }

        /// <summary>
        /// Get current user info.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>Get current user information successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("users/current")]
        public System.Threading.Tasks.Task<UserResp> GetCurrentUserInfo([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id)
        {

            return _implementation.GetCurrentUserInfoAsync(x_Request_Id);
        }

        /// <summary>
        /// Search users by username
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <param name="username">Username for filtering results.</param>
        /// <returns>Search users by username successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("users/search")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<UserSearchRespItem>> SearchUsers([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size, [Microsoft.AspNetCore.Mvc.FromQuery] string username)
        {

            return _implementation.SearchUsersAsync(x_Request_Id, page ?? 1L, page_size ?? 10L, username);
        }

        /// <summary>
        /// Get a user's profile.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>Get user's info successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("users/{user_id}")]
        public System.Threading.Tasks.Task<UserResp> GetUser([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, int user_id)
        {

            return _implementation.GetUserAsync(x_Request_Id, user_id);
        }

        /// <summary>
        /// Update user's profile.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="user_id">Registered user ID</param>
        /// <param name="profile">Only email, realname and comment can be modified.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("users/{user_id}")]
        public System.Threading.Tasks.Task UpdateUserProfile([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, int user_id, [Microsoft.AspNetCore.Mvc.FromBody] UserProfile profile)
        {

            return _implementation.UpdateUserProfileAsync(x_Request_Id, user_id, profile);
        }

        /// <summary>
        /// Mark a registered user as be removed.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="user_id">User ID for marking as to be removed.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("users/{user_id}")]
        public System.Threading.Tasks.Task DeleteUser([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, int user_id)
        {

            return _implementation.DeleteUserAsync(x_Request_Id, user_id);
        }

        /// <summary>
        /// Update a registered user to change to be an administrator of Harbor.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="sysadmin_flag">Toggle a user to admin or not.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("users/{user_id}/sysadmin")]
        public System.Threading.Tasks.Task SetUserSysAdmin([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, int user_id, [Microsoft.AspNetCore.Mvc.FromBody] UserSysAdminFlag sysadmin_flag)
        {

            return _implementation.SetUserSysAdminAsync(x_Request_Id, user_id, sysadmin_flag);
        }

        /// <summary>
        /// Change the password on a user that already exists.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="password">Password to be updated, the attribute 'old_password' is optional when the API is called by the system administrator.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("users/{user_id}/password")]
        public System.Threading.Tasks.Task UpdateUserPassword([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, int user_id, [Microsoft.AspNetCore.Mvc.FromBody] PasswordReq password)
        {

            return _implementation.UpdateUserPasswordAsync(x_Request_Id, user_id, password);
        }

        /// <summary>
        /// Get current user permissions.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="scope">The scope for the permission</param>
        /// <param name="relative">If true, the resources in the response are relative to the scope,
        /// <br/>eg for resource '/project/1/repository' if relative is 'true' then the resource in response will be 'repository'.</param>
        /// <returns>Get current user permission successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("users/current/permissions")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Permission>> GetCurrentUserPermissions([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] string scope, [Microsoft.AspNetCore.Mvc.FromQuery] bool? relative)
        {

            return _implementation.GetCurrentUserPermissionsAsync(x_Request_Id, scope, relative);
        }

        /// <summary>
        /// Set CLI secret for a user.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="user_id">User ID</param>
        /// <returns>The secret is successfully updated</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("users/{user_id}/cli_secret")]
        public System.Threading.Tasks.Task SetCliSecret([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, int user_id, [Microsoft.AspNetCore.Mvc.FromBody] OIDCCliSecretReq secret)
        {

            return _implementation.SetCliSecretAsync(x_Request_Id, user_id, secret);
        }

        /// <summary>
        /// List labels according to the query strings.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="q">Query string to query resources. Supported query patterns are "exact match(k=v)", "fuzzy match(k=~v)", "range(k=[min~max])", "list with union releationship(k={v1 v2 v3})" and "list with intersetion relationship(k=(v1 v2 v3))". The value of range and list can be string(enclosed by " or '), integer or time(in format "2020-04-09 02:36:00"). All of these query patterns should be put in the query string "q=xxx" and splitted by ",". e.g. q=k1=v1,k2=~v2,k3=[min~max]</param>
        /// <param name="sort">Sort the resource list in ascending or descending order. e.g. sort by field1 in ascending orderr and field2 in descending order with "sort=field1,-field2"</param>
        /// <param name="page">The page number</param>
        /// <param name="page_size">The size of per page</param>
        /// <param name="name">The label name.</param>
        /// <param name="scope">The label scope. Valid values are g and p. g for global labels and p for project labels.</param>
        /// <param name="project_id">Relevant project ID, required when scope is p.</param>
        /// <returns>Get successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("labels")]
        public System.Threading.Tasks.Task<System.Collections.Generic.ICollection<Label>> ListLabels([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromQuery] string q, [Microsoft.AspNetCore.Mvc.FromQuery] string sort, [Microsoft.AspNetCore.Mvc.FromQuery] long? page, [Microsoft.AspNetCore.Mvc.FromQuery] long? page_size, [Microsoft.AspNetCore.Mvc.FromQuery] string name, [Microsoft.AspNetCore.Mvc.FromQuery] string scope, [Microsoft.AspNetCore.Mvc.FromQuery] long? project_id)
        {

            return _implementation.ListLabelsAsync(x_Request_Id, q, sort, page ?? 1L, page_size ?? 10L, name, scope, project_id);
        }

        /// <summary>
        /// Post creates a label
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="label">The json object of label.</param>
        /// <returns>Create successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("labels")]
        public System.Threading.Tasks.Task CreateLabel([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromBody] Label label)
        {

            return _implementation.CreateLabelAsync(x_Request_Id, label);
        }

        /// <summary>
        /// Get the label specified by ID.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="label_id">Label ID</param>
        /// <returns>Get successfully.</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("labels/{label_id}")]
        public System.Threading.Tasks.Task<Label> GetLabelByID([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long label_id)
        {

            return _implementation.GetLabelByIDAsync(x_Request_Id, label_id);
        }

        /// <summary>
        /// Update the label properties.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="label_id">Label ID</param>
        /// <param name="label">The updated label json object.</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpPut, Microsoft.AspNetCore.Mvc.Route("labels/{label_id}")]
        public System.Threading.Tasks.Task UpdateLabel([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long label_id, [Microsoft.AspNetCore.Mvc.FromBody] Label label)
        {

            return _implementation.UpdateLabelAsync(x_Request_Id, label_id, label);
        }

        /// <summary>
        /// Delete the label specified by ID.
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="label_id">Label ID</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpDelete, Microsoft.AspNetCore.Mvc.Route("labels/{label_id}")]
        public System.Threading.Tasks.Task DeleteLabel([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, long label_id)
        {

            return _implementation.DeleteLabelAsync(x_Request_Id, label_id);
        }

        /// <summary>
        /// Export scan data for selected projects
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="x_Scan_Data_Type">The type of scan data to export</param>
        /// <param name="criteria">The criteria for the export</param>
        /// <returns>Success.</returns>
        [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("export/cve")]
        public System.Threading.Tasks.Task<ScanDataExportJob> ExportScanData([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, [Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Scan-Data-Type")] string x_Scan_Data_Type, [Microsoft.AspNetCore.Mvc.FromBody] ScanDataExportRequest criteria)
        {

            return _implementation.ExportScanDataAsync(x_Request_Id, x_Scan_Data_Type, criteria);
        }

        /// <summary>
        /// Get the specific scan data export execution
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="execution_id">Execution ID</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("export/cve/execution/{execution_id}")]
        public System.Threading.Tasks.Task<ScanDataExportExecution> GetScanDataExportExecution([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, int execution_id)
        {

            return _implementation.GetScanDataExportExecutionAsync(x_Request_Id, execution_id);
        }

        /// <summary>
        /// Get a list of specific scan data export execution jobs for a specified user
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <returns>Success</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("export/cve/executions")]
        public System.Threading.Tasks.Task<ScanDataExportExecutionList> GetScanDataExportExecutionList([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id)
        {

            return _implementation.GetScanDataExportExecutionListAsync(x_Request_Id);
        }

        /// <summary>
        /// Download the scan data export file
        /// </summary>
        /// <param name="x_Request_Id">An unique ID for the request</param>
        /// <param name="execution_id">Execution ID</param>
        /// <param name="format">The format of the data to be exported. e.g. CSV or PDF</param>
        /// <returns>Data file containing the export data</returns>
        [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("export/cve/download/{execution_id}")]
        public System.Threading.Tasks.Task<FileResult> DownloadScanData([Microsoft.AspNetCore.Mvc.FromHeader(Name = "X-Request-Id")] string x_Request_Id, int execution_id, [Microsoft.AspNetCore.Mvc.FromQuery] string format)
        {

            return _implementation.DownloadScanDataAsync(x_Request_Id, execution_id, format);
        }

    }

    /// <summary>
    /// The error array that describe the errors got during the handling of request
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Errors
    {
        [Newtonsoft.Json.JsonProperty("errors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Error> Errors1 { get; set; }

    }

    /// <summary>
    /// a model for all the error response coming from harbor
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Error
    {
        /// <summary>
        /// The error code
        /// </summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }

        /// <summary>
        /// The error message
        /// </summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Search
    {
        /// <summary>
        /// Search results of the projects that matched the filter keywords.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("project", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Project> Project { get; set; }

        /// <summary>
        /// Search results of the repositories that matched the filter keywords.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("repository", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SearchRepository> Repository { get; set; }

        /// <summary>
        /// Search results of the charts that macthed the filter keywords.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("chart", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<SearchResult> Chart { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SearchRepository
    {
        /// <summary>
        /// The ID of the project that the repository belongs to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("project_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Project_id { get; set; }

        /// <summary>
        /// The name of the project that the repository belongs to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("project_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Project_name { get; set; }

        /// <summary>
        /// The flag to indicate the publicity of the project that the repository belongs to (1 is public, 0 is not)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("project_public", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Project_public { get; set; }

        /// <summary>
        /// The name of the repository
        /// </summary>
        [Newtonsoft.Json.JsonProperty("repository_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Repository_name { get; set; }

        /// <summary>
        /// The count how many times the repository is pulled
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pull_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Pull_count { get; set; }

        /// <summary>
        /// The count of artifacts in the repository
        /// </summary>
        [Newtonsoft.Json.JsonProperty("artifact_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Artifact_count { get; set; }

    }

    /// <summary>
    /// The chart search result item
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SearchResult
    {
        /// <summary>
        /// The chart name with repo name
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The matched level
        /// </summary>
        [Newtonsoft.Json.JsonProperty("Score", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Score { get; set; }

        [Newtonsoft.Json.JsonProperty("Chart", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ChartVersion Chart { get; set; }

    }

    /// <summary>
    /// A specified chart entry
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ChartVersion : ChartMetadata
    {
        /// <summary>
        /// A list of label
        /// </summary>
        [Newtonsoft.Json.JsonProperty("labels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Label> Labels { get; set; }

        /// <summary>
        /// The created time of the chart entry
        /// </summary>
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Created { get; set; }

        /// <summary>
        /// A flag to indicate if the chart entry is removed
        /// </summary>
        [Newtonsoft.Json.JsonProperty("removed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Removed { get; set; }

        /// <summary>
        /// The digest value of the chart entry
        /// </summary>
        [Newtonsoft.Json.JsonProperty("digest", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Digest { get; set; }

        /// <summary>
        /// The urls of the chart entry
        /// </summary>
        [Newtonsoft.Json.JsonProperty("urls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Urls { get; set; }

    }

    /// <summary>
    /// The metadata of chart version
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ChartMetadata
    {
        /// <summary>
        /// The name of the chart
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The URL to the relevant project page
        /// </summary>
        [Newtonsoft.Json.JsonProperty("home", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Home { get; set; }

        /// <summary>
        /// The URL to the source code of chart
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Sources { get; set; }

        /// <summary>
        /// A SemVer 2 version of chart
        /// </summary>
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Version { get; set; }

        /// <summary>
        /// A one-sentence description of chart
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// A list of string keywords
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keywords", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Keywords { get; set; }

        /// <summary>
        /// The name of template engine
        /// </summary>
        [Newtonsoft.Json.JsonProperty("engine", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Engine { get; set; }

        /// <summary>
        /// The URL to an icon file
        /// </summary>
        [Newtonsoft.Json.JsonProperty("icon", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Icon { get; set; }

        /// <summary>
        /// The API version of this chart
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apiVersion", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ApiVersion { get; set; }

        /// <summary>
        /// The version of the application enclosed in the chart
        /// </summary>
        [Newtonsoft.Json.JsonProperty("appVersion", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AppVersion { get; set; }

        /// <summary>
        /// Whether or not this chart is deprecated
        /// </summary>
        [Newtonsoft.Json.JsonProperty("deprecated", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Deprecated { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Repository
    {
        /// <summary>
        /// The ID of the repository
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Id { get; set; }

        /// <summary>
        /// The ID of the project that the repository belongs to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("project_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Project_id { get; set; }

        /// <summary>
        /// The name of the repository
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The description of the repository
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// The count of the artifacts inside the repository
        /// </summary>
        [Newtonsoft.Json.JsonProperty("artifact_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Artifact_count { get; set; }

        /// <summary>
        /// The count that the artifact inside the repository pulled
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pull_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Pull_count { get; set; }

        /// <summary>
        /// The creation time of the repository
        /// </summary>
        [Newtonsoft.Json.JsonProperty("creation_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Creation_time { get; set; }

        /// <summary>
        /// The update time of the repository
        /// </summary>
        [Newtonsoft.Json.JsonProperty("update_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Update_time { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Artifact
    {
        /// <summary>
        /// The ID of the artifact
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Id { get; set; }

        /// <summary>
        /// The type of the artifact, e.g. image, chart, etc
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>
        /// The media type of the artifact
        /// </summary>
        [Newtonsoft.Json.JsonProperty("media_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Media_type { get; set; }

        /// <summary>
        /// The manifest media type of the artifact
        /// </summary>
        [Newtonsoft.Json.JsonProperty("manifest_media_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Manifest_media_type { get; set; }

        /// <summary>
        /// The ID of the project that the artifact belongs to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("project_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Project_id { get; set; }

        /// <summary>
        /// The ID of the repository that the artifact belongs to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("repository_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Repository_id { get; set; }

        /// <summary>
        /// The digest of the artifact
        /// </summary>
        [Newtonsoft.Json.JsonProperty("digest", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Digest { get; set; }

        /// <summary>
        /// The size of the artifact
        /// </summary>
        [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Size { get; set; }

        /// <summary>
        /// The digest of the icon
        /// </summary>
        [Newtonsoft.Json.JsonProperty("icon", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Icon { get; set; }

        /// <summary>
        /// The push time of the artifact
        /// </summary>
        [Newtonsoft.Json.JsonProperty("push_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Push_time { get; set; }

        /// <summary>
        /// The latest pull time of the artifact
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pull_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Pull_time { get; set; }

        [Newtonsoft.Json.JsonProperty("extra_attrs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ExtraAttrs Extra_attrs { get; set; }

        [Newtonsoft.Json.JsonProperty("annotations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Annotations Annotations { get; set; }

        [Newtonsoft.Json.JsonProperty("references", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Reference> References { get; set; }

        [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Tag> Tags { get; set; }

        [Newtonsoft.Json.JsonProperty("addition_links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AdditionLinks Addition_links { get; set; }

        [Newtonsoft.Json.JsonProperty("labels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Label> Labels { get; set; }

        /// <summary>
        /// The overview of the scan result.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scan_overview", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ScanOverview Scan_overview { get; set; }

        [Newtonsoft.Json.JsonProperty("accessories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<Accessory> Accessories { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Tag
    {
        /// <summary>
        /// The ID of the tag
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Id { get; set; }

        /// <summary>
        /// The ID of the repository that the tag belongs to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("repository_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Repository_id { get; set; }

        /// <summary>
        /// The ID of the artifact that the tag attached to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("artifact_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Artifact_id { get; set; }

        /// <summary>
        /// The name of the tag
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The push time of the tag
        /// </summary>
        [Newtonsoft.Json.JsonProperty("push_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Push_time { get; set; }

        /// <summary>
        /// The latest pull time of the tag
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pull_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Pull_time { get; set; }

        /// <summary>
        /// The immutable status of the tag
        /// </summary>
        [Newtonsoft.Json.JsonProperty("immutable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Immutable { get; set; }

        /// <summary>
        /// The attribute indicates whether the tag is signed or not
        /// </summary>
        [Newtonsoft.Json.JsonProperty("signed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Signed { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ExtraAttrs : System.Collections.Generic.Dictionary<string, object>
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Annotations : System.Collections.Generic.Dictionary<string, string>
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AdditionLinks : System.Collections.Generic.Dictionary<string, AdditionLink>
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AdditionLink
    {
        /// <summary>
        /// The link of the addition
        /// </summary>
        [Newtonsoft.Json.JsonProperty("href", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Href { get; set; }

        /// <summary>
        /// Determine whether the link is an absolute URL or not
        /// </summary>
        [Newtonsoft.Json.JsonProperty("absolute", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Absolute { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Reference
    {
        /// <summary>
        /// The parent ID of the reference
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parent_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Parent_id { get; set; }

        /// <summary>
        /// The child ID of the reference
        /// </summary>
        [Newtonsoft.Json.JsonProperty("child_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Child_id { get; set; }

        /// <summary>
        /// The digest of the child artifact
        /// </summary>
        [Newtonsoft.Json.JsonProperty("child_digest", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Child_digest { get; set; }

        [Newtonsoft.Json.JsonProperty("platform", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Platform Platform { get; set; }

        [Newtonsoft.Json.JsonProperty("annotations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Annotations Annotations { get; set; }

        /// <summary>
        /// The download URLs
        /// </summary>
        [Newtonsoft.Json.JsonProperty("urls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.List<string> Urls { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Platform
    {
        /// <summary>
        /// The architecture that the artifact applys to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("architecture", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Architecture { get; set; }

        /// <summary>
        /// The OS that the artifact applys to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("os", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Os { get; set; }

        /// <summary>
        /// The version of the OS that the artifact applys to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("'os.version'", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string osVersion{ get; set; }

    /// <summary>
    /// The features of the OS that the artifact applys to
    /// </summary>
    [Newtonsoft.Json.JsonProperty("'os.features'", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<string> osFeatures { get; set; }

/// <summary>
/// The variant of the CPU
/// </summary>
[Newtonsoft.Json.JsonProperty("variant", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
public string Variant { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Label
{
    /// <summary>
    /// The ID of the label
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Id { get; set; }

    /// <summary>
    /// The name the label
    /// </summary>
    [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Name { get; set; }

    /// <summary>
    /// The description the label
    /// </summary>
    [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Description { get; set; }

    /// <summary>
    /// The color the label
    /// </summary>
    [Newtonsoft.Json.JsonProperty("color", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Color { get; set; }

    /// <summary>
    /// The scope the label
    /// </summary>
    [Newtonsoft.Json.JsonProperty("scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Scope { get; set; }

    /// <summary>
    /// The ID of project that the label belongs to
    /// </summary>
    [Newtonsoft.Json.JsonProperty("project_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Project_id { get; set; }

    /// <summary>
    /// The creation time the label
    /// </summary>
    [Newtonsoft.Json.JsonProperty("creation_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Creation_time { get; set; }

    /// <summary>
    /// The update time of the label
    /// </summary>
    [Newtonsoft.Json.JsonProperty("update_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Update_time { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Scanner
{
    /// <summary>
    /// Name of the scanner
    /// </summary>
    [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Name { get; set; }

    /// <summary>
    /// Name of the scanner provider
    /// </summary>
    [Newtonsoft.Json.JsonProperty("vendor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Vendor { get; set; }

    /// <summary>
    /// Version of the scanner adapter
    /// </summary>
    [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Version { get; set; }

}

/// <summary>
/// The scan overview attached in the metadata of tag
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ScanOverview : System.Collections.Generic.Dictionary<string, NativeReportSummary>
{

}

/// <summary>
/// The summary for the native report
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class NativeReportSummary
{
    /// <summary>
    /// id of the native scan report
    /// </summary>
    [Newtonsoft.Json.JsonProperty("report_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Report_id { get; set; }

    /// <summary>
    /// The status of the report generating process
    /// </summary>
    [Newtonsoft.Json.JsonProperty("scan_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Scan_status { get; set; }

    /// <summary>
    /// The overall severity
    /// </summary>
    [Newtonsoft.Json.JsonProperty("severity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Severity { get; set; }

    /// <summary>
    /// The seconds spent for generating the report
    /// </summary>
    [Newtonsoft.Json.JsonProperty("duration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Duration { get; set; }

    [Newtonsoft.Json.JsonProperty("summary", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public VulnerabilitySummary Summary { get; set; }

    /// <summary>
    /// The start time of the scan process that generating report
    /// </summary>
    [Newtonsoft.Json.JsonProperty("start_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Start_time { get; set; }

    /// <summary>
    /// The end time of the scan process that generating report
    /// </summary>
    [Newtonsoft.Json.JsonProperty("end_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? End_time { get; set; }

    /// <summary>
    /// The complete percent of the scanning which value is between 0 and 100
    /// </summary>
    [Newtonsoft.Json.JsonProperty("complete_percent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Complete_percent { get; set; }

    [Newtonsoft.Json.JsonProperty("scanner", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public Scanner Scanner { get; set; }

}

/// <summary>
/// VulnerabilitySummary contains the total number of the foun d vulnerabilities number and numbers of each severity level.
/// <br/>
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class VulnerabilitySummary
{
    /// <summary>
    /// The total number of the found vulnerabilities
    /// </summary>
    [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Total { get; set; }

    /// <summary>
    /// The number of the fixable vulnerabilities
    /// </summary>
    [Newtonsoft.Json.JsonProperty("fixable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Fixable { get; set; }

    /// <summary>
    /// Numbers of the vulnerabilities with different severity
    /// </summary>
    [Newtonsoft.Json.JsonProperty("summary", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.IDictionary<string, int> Summary { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class AuditLog
{
    /// <summary>
    /// The ID of the audit log entry.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Id { get; set; }

    /// <summary>
    /// Username of the user in this log entry.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Username { get; set; }

    /// <summary>
    /// Name of the repository in this log entry.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("resource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Resource { get; set; }

    /// <summary>
    /// Tag of the repository in this log entry.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("resource_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Resource_type { get; set; }

    /// <summary>
    /// The operation against the repository in this log entry.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("operation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Operation { get; set; }

    /// <summary>
    /// The time when this operation is triggered.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("op_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Op_time { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Metadata
{
    /// <summary>
    /// id
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Id { get; set; }

    /// <summary>
    /// name
    /// </summary>
    [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Name { get; set; }

    /// <summary>
    /// icon
    /// </summary>
    [Newtonsoft.Json.JsonProperty("icon", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Icon { get; set; }

    /// <summary>
    /// maintainers
    /// </summary>
    [Newtonsoft.Json.JsonProperty("maintainers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<string> Maintainers { get; set; }

    /// <summary>
    /// version
    /// </summary>
    [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Version { get; set; }

    /// <summary>
    /// source
    /// </summary>
    [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Source { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Instance
{
    /// <summary>
    /// Unique ID
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Id { get; set; }

    /// <summary>
    /// Instance name
    /// </summary>
    [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Name { get; set; }

    /// <summary>
    /// Description of instance
    /// </summary>
    [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Description { get; set; }

    /// <summary>
    /// Based on which driver, identified by ID
    /// </summary>
    [Newtonsoft.Json.JsonProperty("vendor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Vendor { get; set; }

    /// <summary>
    /// The service endpoint of this instance
    /// </summary>
    [Newtonsoft.Json.JsonProperty("endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Endpoint { get; set; }

    /// <summary>
    /// The authentication way supported
    /// </summary>
    [Newtonsoft.Json.JsonProperty("auth_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Auth_mode { get; set; }

    /// <summary>
    /// The auth credential data if exists
    /// </summary>
    [Newtonsoft.Json.JsonProperty("auth_info", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.IDictionary<string, string> Auth_info { get; set; }

    /// <summary>
    /// The health status
    /// </summary>
    [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Status { get; set; }

    /// <summary>
    /// Whether the instance is activated or not
    /// </summary>
    [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Enabled { get; set; }

    /// <summary>
    /// Whether the instance is default or not
    /// </summary>
    [Newtonsoft.Json.JsonProperty("default", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Default { get; set; }

    /// <summary>
    /// Whether the instance endpoint is insecure or not
    /// </summary>
    [Newtonsoft.Json.JsonProperty("insecure", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Insecure { get; set; }

    /// <summary>
    /// The timestamp of instance setting up
    /// </summary>
    [Newtonsoft.Json.JsonProperty("setup_timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Setup_timestamp { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class PreheatPolicy
{
    /// <summary>
    /// The ID of preheat policy
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Id { get; set; }

    /// <summary>
    /// The Name of preheat policy
    /// </summary>
    [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Name { get; set; }

    /// <summary>
    /// The Description of preheat policy
    /// </summary>
    [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Description { get; set; }

    /// <summary>
    /// The ID of preheat policy project
    /// </summary>
    [Newtonsoft.Json.JsonProperty("project_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Project_id { get; set; }

    /// <summary>
    /// The ID of preheat policy provider
    /// </summary>
    [Newtonsoft.Json.JsonProperty("provider_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Provider_id { get; set; }

    /// <summary>
    /// The Name of preheat policy provider
    /// </summary>
    [Newtonsoft.Json.JsonProperty("provider_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Provider_name { get; set; }

    /// <summary>
    /// The Filters of preheat policy
    /// </summary>
    [Newtonsoft.Json.JsonProperty("filters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Filters { get; set; }

    /// <summary>
    /// The Trigger of preheat policy
    /// </summary>
    [Newtonsoft.Json.JsonProperty("trigger", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Trigger { get; set; }

    /// <summary>
    /// Whether the preheat policy enabled
    /// </summary>
    [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Enabled { get; set; }

    /// <summary>
    /// The Create Time of preheat policy
    /// </summary>
    [Newtonsoft.Json.JsonProperty("creation_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Creation_time { get; set; }

    /// <summary>
    /// The Update Time of preheat policy
    /// </summary>
    [Newtonsoft.Json.JsonProperty("update_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Update_time { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Metrics
{
    /// <summary>
    /// The count of task
    /// </summary>
    [Newtonsoft.Json.JsonProperty("task_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Task_count { get; set; }

    /// <summary>
    /// The count of success task
    /// </summary>
    [Newtonsoft.Json.JsonProperty("success_task_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Success_task_count { get; set; }

    /// <summary>
    /// The count of error task
    /// </summary>
    [Newtonsoft.Json.JsonProperty("error_task_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Error_task_count { get; set; }

    /// <summary>
    /// The count of pending task
    /// </summary>
    [Newtonsoft.Json.JsonProperty("pending_task_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Pending_task_count { get; set; }

    /// <summary>
    /// The count of running task
    /// </summary>
    [Newtonsoft.Json.JsonProperty("running_task_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Running_task_count { get; set; }

    /// <summary>
    /// The count of scheduled task
    /// </summary>
    [Newtonsoft.Json.JsonProperty("scheduled_task_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Scheduled_task_count { get; set; }

    /// <summary>
    /// The count of stopped task
    /// </summary>
    [Newtonsoft.Json.JsonProperty("stopped_task_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Stopped_task_count { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Execution
{
    /// <summary>
    /// The ID of execution
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Id { get; set; }

    /// <summary>
    /// The vendor type of execution
    /// </summary>
    [Newtonsoft.Json.JsonProperty("vendor_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Vendor_type { get; set; }

    /// <summary>
    /// The vendor id of execution
    /// </summary>
    [Newtonsoft.Json.JsonProperty("vendor_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Vendor_id { get; set; }

    /// <summary>
    /// The status of execution
    /// </summary>
    [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Status { get; set; }

    /// <summary>
    /// The status message of execution
    /// </summary>
    [Newtonsoft.Json.JsonProperty("status_message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Status_message { get; set; }

    [Newtonsoft.Json.JsonProperty("metrics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public Metrics Metrics { get; set; }

    /// <summary>
    /// The trigger of execution
    /// </summary>
    [Newtonsoft.Json.JsonProperty("trigger", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Trigger { get; set; }

    [Newtonsoft.Json.JsonProperty("extra_attrs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public ExtraAttrs Extra_attrs { get; set; }

    /// <summary>
    /// The start time of execution
    /// </summary>
    [Newtonsoft.Json.JsonProperty("start_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Start_time { get; set; }

    /// <summary>
    /// The end time of execution
    /// </summary>
    [Newtonsoft.Json.JsonProperty("end_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string End_time { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Task
{
    /// <summary>
    /// The ID of task
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Id { get; set; }

    /// <summary>
    /// The ID of task execution
    /// </summary>
    [Newtonsoft.Json.JsonProperty("execution_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Execution_id { get; set; }

    /// <summary>
    /// The status of task
    /// </summary>
    [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Status { get; set; }

    /// <summary>
    /// The status message of task
    /// </summary>
    [Newtonsoft.Json.JsonProperty("status_message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Status_message { get; set; }

    /// <summary>
    /// The count of task run
    /// </summary>
    [Newtonsoft.Json.JsonProperty("run_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Run_count { get; set; }

    [Newtonsoft.Json.JsonProperty("extra_attrs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public ExtraAttrs Extra_attrs { get; set; }

    /// <summary>
    /// The creation time of task
    /// </summary>
    [Newtonsoft.Json.JsonProperty("creation_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Creation_time { get; set; }

    /// <summary>
    /// The update time of task
    /// </summary>
    [Newtonsoft.Json.JsonProperty("update_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Update_time { get; set; }

    /// <summary>
    /// The start time of task
    /// </summary>
    [Newtonsoft.Json.JsonProperty("start_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Start_time { get; set; }

    /// <summary>
    /// The end time of task
    /// </summary>
    [Newtonsoft.Json.JsonProperty("end_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string End_time { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ProviderUnderProject
{
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Id { get; set; }

    [Newtonsoft.Json.JsonProperty("provider", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Provider { get; set; }

    [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Enabled { get; set; }

    [Newtonsoft.Json.JsonProperty("default", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Default { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Icon
{
    /// <summary>
    /// The content type of the icon
    /// </summary>
    [Newtonsoft.Json.JsonProperty("content-type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string ContentType { get; set; }

    /// <summary>
    /// The base64 encoded content of the icon
    /// </summary>
    [Newtonsoft.Json.JsonProperty("content", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Content { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ProjectReq
{
    /// <summary>
    /// The name of the project.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("project_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    [System.ComponentModel.DataAnnotations.StringLength(255)]
    public string Project_name { get; set; }

    /// <summary>
    /// deprecated, reserved for project creation in replication
    /// </summary>
    [Newtonsoft.Json.JsonProperty("public", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Public { get; set; }

    /// <summary>
    /// The metadata of the project.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public ProjectMetadata Metadata { get; set; }

    /// <summary>
    /// The CVE allowlist of the project.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("cve_allowlist", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public CVEAllowlist Cve_allowlist { get; set; }

    /// <summary>
    /// The storage quota of the project.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("storage_limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Storage_limit { get; set; }

    /// <summary>
    /// The ID of referenced registry when creating the proxy cache project
    /// </summary>
    [Newtonsoft.Json.JsonProperty("registry_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Registry_id { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Project
{
    /// <summary>
    /// Project ID
    /// </summary>
    [Newtonsoft.Json.JsonProperty("project_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Project_id { get; set; }

    /// <summary>
    /// The owner ID of the project always means the creator of the project.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("owner_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Owner_id { get; set; }

    /// <summary>
    /// The name of the project.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Name { get; set; }

    /// <summary>
    /// The ID of referenced registry when the project is a proxy cache project.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("registry_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Registry_id { get; set; }

    /// <summary>
    /// The creation time of the project.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("creation_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Creation_time { get; set; }

    /// <summary>
    /// The update time of the project.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("update_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Update_time { get; set; }

    /// <summary>
    /// A deletion mark of the project.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("deleted", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Deleted { get; set; }

    /// <summary>
    /// The owner name of the project.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("owner_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Owner_name { get; set; }

    /// <summary>
    /// Correspond to the UI about whether the project's publicity is  updatable (for UI)
    /// </summary>
    [Newtonsoft.Json.JsonProperty("togglable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Togglable { get; set; }

    /// <summary>
    /// The role ID with highest permission of the current user who triggered the API (for UI).  This attribute is deprecated and will be removed in future versions.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("current_user_role_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Current_user_role_id { get; set; }

    /// <summary>
    /// The list of role ID of the current user who triggered the API (for UI)
    /// </summary>
    [Newtonsoft.Json.JsonProperty("current_user_role_ids", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<int> Current_user_role_ids { get; set; }

    /// <summary>
    /// The number of the repositories under this project.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("repo_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Repo_count { get; set; }

    /// <summary>
    /// The total number of charts under this project.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("chart_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Chart_count { get; set; }

    /// <summary>
    /// The metadata of the project.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public ProjectMetadata Metadata { get; set; }

    /// <summary>
    /// The CVE allowlist of this project.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("cve_allowlist", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public CVEAllowlist Cve_allowlist { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ProjectDeletable
{
    /// <summary>
    /// Whether the project can be deleted.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("deletable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Deletable { get; set; }

    /// <summary>
    /// The detail message when the project can not be deleted.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Message { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ProjectMetadata
{
    /// <summary>
    /// The public status of the project. The valid values are "true", "false".
    /// </summary>
    [Newtonsoft.Json.JsonProperty("public", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Public { get; set; }

    /// <summary>
    /// Whether content trust is enabled or not. If it is enabled, user can't pull unsigned images from this project. The valid values are "true", "false".
    /// </summary>
    [Newtonsoft.Json.JsonProperty("enable_content_trust", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Enable_content_trust { get; set; }

    /// <summary>
    /// Whether cosign content trust is enabled or not. If it is enabled, user can't pull images without cosign signature from this project. The valid values are "true", "false".
    /// </summary>
    [Newtonsoft.Json.JsonProperty("enable_content_trust_cosign", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Enable_content_trust_cosign { get; set; }

    /// <summary>
    /// Whether prevent the vulnerable images from running. The valid values are "true", "false".
    /// </summary>
    [Newtonsoft.Json.JsonProperty("prevent_vul", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Prevent_vul { get; set; }

    /// <summary>
    /// If the vulnerability is high than severity defined here, the images can't be pulled. The valid values are "none", "low", "medium", "high", "critical".
    /// </summary>
    [Newtonsoft.Json.JsonProperty("severity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Severity { get; set; }

    /// <summary>
    /// Whether scan images automatically when pushing. The valid values are "true", "false".
    /// </summary>
    [Newtonsoft.Json.JsonProperty("auto_scan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Auto_scan { get; set; }

    /// <summary>
    /// Whether this project reuse the system level CVE allowlist as the allowlist of its own.  The valid values are "true", "false". If it is set to "true" the actual allowlist associate with this project, if any, will be ignored.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("reuse_sys_cve_allowlist", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Reuse_sys_cve_allowlist { get; set; }

    /// <summary>
    /// The ID of the tag retention policy for the project
    /// </summary>
    [Newtonsoft.Json.JsonProperty("retention_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Retention_id { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ProjectSummary
{
    /// <summary>
    /// The number of the repositories under this project.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("repo_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Repo_count { get; set; }

    /// <summary>
    /// The total number of charts under this project.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("chart_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Chart_count { get; set; }

    /// <summary>
    /// The total number of project admin members.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("project_admin_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Project_admin_count { get; set; }

    /// <summary>
    /// The total number of maintainer members.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("maintainer_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Maintainer_count { get; set; }

    /// <summary>
    /// The total number of developer members.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("developer_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Developer_count { get; set; }

    /// <summary>
    /// The total number of guest members.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("guest_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Guest_count { get; set; }

    /// <summary>
    /// The total number of limited guest members.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("limited_guest_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Limited_guest_count { get; set; }

    [Newtonsoft.Json.JsonProperty("quota", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public ProjectSummaryQuota Quota { get; set; }

    [Newtonsoft.Json.JsonProperty("registry", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public Registry Registry { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ProjectSummaryQuota
{
    /// <summary>
    /// The hard limits of the quota
    /// </summary>
    [Newtonsoft.Json.JsonProperty("hard", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public ResourceList Hard { get; set; }

    /// <summary>
    /// The used status of the quota
    /// </summary>
    [Newtonsoft.Json.JsonProperty("used", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public ResourceList Used { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ProjectScanner
{
    /// <summary>
    /// The identifier of the scanner registration
    /// </summary>
    [Newtonsoft.Json.JsonProperty("uuid", Required = Newtonsoft.Json.Required.Always)]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    public string Uuid { get; set; }

}

/// <summary>
/// The CVE Allowlist for system or project
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class CVEAllowlist
{
    /// <summary>
    /// ID of the allowlist
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Id { get; set; }

    /// <summary>
    /// ID of the project which the allowlist belongs to.  For system level allowlist this attribute is zero.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("project_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Project_id { get; set; }

    /// <summary>
    /// the time for expiration of the allowlist, in the form of seconds since epoch.  This is an optional attribute, if it's not set the CVE allowlist does not expire.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("expires_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Expires_at { get; set; }

    [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<CVEAllowlistItem> Items { get; set; }

    /// <summary>
    /// The creation time of the allowlist.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("creation_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Creation_time { get; set; }

    /// <summary>
    /// The update time of the allowlist.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("update_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Update_time { get; set; }

}

/// <summary>
/// The item in CVE allowlist
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class CVEAllowlistItem
{
    /// <summary>
    /// The ID of the CVE, such as "CVE-2019-10164"
    /// </summary>
    [Newtonsoft.Json.JsonProperty("cve_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Cve_id { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ReplicationPolicy
{
    /// <summary>
    /// The policy ID.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Id { get; set; }

    /// <summary>
    /// The policy name.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Name { get; set; }

    /// <summary>
    /// The description of the policy.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Description { get; set; }

    /// <summary>
    /// The source registry.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("src_registry", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public Registry Src_registry { get; set; }

    /// <summary>
    /// The destination registry.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("dest_registry", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public Registry Dest_registry { get; set; }

    /// <summary>
    /// The destination namespace.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("dest_namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Dest_namespace { get; set; }

    /// <summary>
    /// Specify how many path components will be replaced by the provided destination namespace.
    /// <br/>The default value is -1 in which case the legacy mode will be applied.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("dest_namespace_replace_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Dest_namespace_replace_count { get; set; }

    [Newtonsoft.Json.JsonProperty("trigger", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public ReplicationTrigger Trigger { get; set; }

    /// <summary>
    /// The replication policy filter array.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("filters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<ReplicationFilter> Filters { get; set; }

    /// <summary>
    /// Whether to replicate the deletion operation.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("replicate_deletion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Replicate_deletion { get; set; }

    /// <summary>
    /// Deprecated, use "replicate_deletion" instead. Whether to replicate the deletion operation.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("deletion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Deletion { get; set; }

    /// <summary>
    /// Whether to override the resources on the destination registry.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("override", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Override { get; set; }

    /// <summary>
    /// Whether the policy is enabled or not.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Enabled { get; set; }

    /// <summary>
    /// The create time of the policy.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("creation_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Creation_time { get; set; }

    /// <summary>
    /// The update time of the policy.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("update_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Update_time { get; set; }

    /// <summary>
    /// speed limit for each task
    /// </summary>
    [Newtonsoft.Json.JsonProperty("speed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Speed { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ReplicationTrigger
{
    /// <summary>
    /// The replication policy trigger type. The valid values are manual, event_based and scheduled.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Type { get; set; }

    [Newtonsoft.Json.JsonProperty("trigger_settings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public ReplicationTriggerSettings Trigger_settings { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ReplicationTriggerSettings
{
    /// <summary>
    /// The cron string for scheduled trigger
    /// </summary>
    [Newtonsoft.Json.JsonProperty("cron", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Cron { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ReplicationFilter
{
    /// <summary>
    /// The replication policy filter type.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Type { get; set; }

    /// <summary>
    /// The value of replication policy filter.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public object Value { get; set; }

    /// <summary>
    /// matches or excludes the result
    /// </summary>
    [Newtonsoft.Json.JsonProperty("decoration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Decoration { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RegistryCredential
{
    /// <summary>
    /// Credential type, such as 'basic', 'oauth'.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Type { get; set; }

    /// <summary>
    /// Access key, e.g. user name when credential type is 'basic'.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("access_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Access_key { get; set; }

    /// <summary>
    /// Access secret, e.g. password when credential type is 'basic'.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("access_secret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Access_secret { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Registry
{
    /// <summary>
    /// The registry ID.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Id { get; set; }

    /// <summary>
    /// The registry URL string.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Url { get; set; }

    /// <summary>
    /// The registry name.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Name { get; set; }

    [Newtonsoft.Json.JsonProperty("credential", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public RegistryCredential Credential { get; set; }

    /// <summary>
    /// Type of the registry, e.g. 'harbor'.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Type { get; set; }

    /// <summary>
    /// Whether or not the certificate will be verified when Harbor tries to access the server.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("insecure", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Insecure { get; set; }

    /// <summary>
    /// Description of the registry.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Description { get; set; }

    /// <summary>
    /// Health status of the registry.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Status { get; set; }

    /// <summary>
    /// The create time of the policy.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("creation_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Creation_time { get; set; }

    /// <summary>
    /// The update time of the policy.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("update_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Update_time { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RegistryUpdate
{
    /// <summary>
    /// The registry name.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Name { get; set; }

    /// <summary>
    /// Description of the registry.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Description { get; set; }

    /// <summary>
    /// The registry URL.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Url { get; set; }

    /// <summary>
    /// Credential type of the registry, e.g. 'basic'.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("credential_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Credential_type { get; set; }

    /// <summary>
    /// The registry access key.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("access_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Access_key { get; set; }

    /// <summary>
    /// The registry access secret.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("access_secret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Access_secret { get; set; }

    /// <summary>
    /// Whether or not the certificate will be verified when Harbor tries to access the server.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("insecure", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Insecure { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RegistryPing
{
    /// <summary>
    /// The registry ID.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Id { get; set; }

    /// <summary>
    /// Type of the registry, e.g. 'harbor'.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Type { get; set; }

    /// <summary>
    /// The registry URL.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Url { get; set; }

    /// <summary>
    /// Credential type of the registry, e.g. 'basic'.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("credential_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Credential_type { get; set; }

    /// <summary>
    /// The registry access key.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("access_key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Access_key { get; set; }

    /// <summary>
    /// The registry access secret.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("access_secret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Access_secret { get; set; }

    /// <summary>
    /// Whether or not the certificate will be verified when Harbor tries to access the server.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("insecure", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Insecure { get; set; }

}

/// <summary>
/// The registry info contains the base info and capability declarations of the registry
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RegistryInfo
{
    /// <summary>
    /// The registry type
    /// </summary>
    [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Type { get; set; }

    /// <summary>
    /// The description
    /// </summary>
    [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Description { get; set; }

    /// <summary>
    /// The filters that the registry supports
    /// </summary>
    [Newtonsoft.Json.JsonProperty("supported_resource_filters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<FilterStyle> Supported_resource_filters { get; set; }

    /// <summary>
    /// The triggers that the registry supports
    /// </summary>
    [Newtonsoft.Json.JsonProperty("supported_triggers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<string> Supported_triggers { get; set; }

}

/// <summary>
/// The registry provider info contains the base info and capability declarations of the registry provider
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RegistryProviderInfo
{
    /// <summary>
    /// The endpoint pattern
    /// </summary>
    [Newtonsoft.Json.JsonProperty("endpoint_pattern", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public RegistryProviderEndpointPattern Endpoint_pattern { get; set; }

    /// <summary>
    /// The credential pattern
    /// </summary>
    [Newtonsoft.Json.JsonProperty("credential_pattern", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public RegistryProviderCredentialPattern Credential_pattern { get; set; }

}

/// <summary>
/// The registry endpoint pattern
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RegistryProviderEndpointPattern
{
    /// <summary>
    /// The endpoint type
    /// </summary>
    [Newtonsoft.Json.JsonProperty("endpoint_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Endpoint_type { get; set; }

    /// <summary>
    /// The endpoint list
    /// </summary>
    [Newtonsoft.Json.JsonProperty("endpoints", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<RegistryEndpoint> Endpoints { get; set; }

}

/// <summary>
/// The registry credential pattern
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RegistryProviderCredentialPattern
{
    /// <summary>
    /// The access key type
    /// </summary>
    [Newtonsoft.Json.JsonProperty("access_key_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Access_key_type { get; set; }

    /// <summary>
    /// The access key data
    /// </summary>
    [Newtonsoft.Json.JsonProperty("access_key_data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Access_key_data { get; set; }

    /// <summary>
    /// The access secret type
    /// </summary>
    [Newtonsoft.Json.JsonProperty("access_secret_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Access_secret_type { get; set; }

    /// <summary>
    /// The access secret data
    /// </summary>
    [Newtonsoft.Json.JsonProperty("access_secret_data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Access_secret_data { get; set; }

}

/// <summary>
/// The style of the resource filter
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RegistryEndpoint
{
    /// <summary>
    /// The endpoint key
    /// </summary>
    [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Key { get; set; }

    /// <summary>
    /// The endpoint value
    /// </summary>
    [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Value { get; set; }

}

/// <summary>
/// The style of the resource filter
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class FilterStyle
{
    /// <summary>
    /// The filter type
    /// </summary>
    [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Type { get; set; }

    /// <summary>
    /// The filter style
    /// </summary>
    [Newtonsoft.Json.JsonProperty("style", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Style { get; set; }

    /// <summary>
    /// The filter values
    /// </summary>
    [Newtonsoft.Json.JsonProperty("values", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<string> Values { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ResourceList : System.Collections.Generic.Dictionary<string, long>
{

}

/// <summary>
/// The replication execution
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ReplicationExecution
{
    /// <summary>
    /// The ID of the execution
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Id { get; set; }

    /// <summary>
    /// The ID if the policy that the execution belongs to
    /// </summary>
    [Newtonsoft.Json.JsonProperty("policy_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Policy_id { get; set; }

    /// <summary>
    /// The status of the execution
    /// </summary>
    [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Status { get; set; }

    /// <summary>
    /// The trigger mode
    /// </summary>
    [Newtonsoft.Json.JsonProperty("trigger", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Trigger { get; set; }

    /// <summary>
    /// The start time
    /// </summary>
    [Newtonsoft.Json.JsonProperty("start_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Start_time { get; set; }

    /// <summary>
    /// The end time
    /// </summary>
    [Newtonsoft.Json.JsonProperty("end_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? End_time { get; set; }

    /// <summary>
    /// The status text
    /// </summary>
    [Newtonsoft.Json.JsonProperty("status_text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Status_text { get; set; }

    /// <summary>
    /// The total count of all executions
    /// </summary>
    [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Total { get; set; }

    /// <summary>
    /// The count of failed executions
    /// </summary>
    [Newtonsoft.Json.JsonProperty("failed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Failed { get; set; }

    /// <summary>
    /// The count of succeed executions
    /// </summary>
    [Newtonsoft.Json.JsonProperty("succeed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Succeed { get; set; }

    /// <summary>
    /// The count of in_progress executions
    /// </summary>
    [Newtonsoft.Json.JsonProperty("in_progress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? In_progress { get; set; }

    /// <summary>
    /// The count of stopped executions
    /// </summary>
    [Newtonsoft.Json.JsonProperty("stopped", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Stopped { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class StartReplicationExecution
{
    /// <summary>
    /// The ID of policy that the execution belongs to.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("policy_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Policy_id { get; set; }

}

/// <summary>
/// The replication task
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ReplicationTask
{
    /// <summary>
    /// The ID of the task
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Id { get; set; }

    /// <summary>
    /// The ID of the execution that the task belongs to
    /// </summary>
    [Newtonsoft.Json.JsonProperty("execution_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Execution_id { get; set; }

    /// <summary>
    /// The status of the task
    /// </summary>
    [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Status { get; set; }

    /// <summary>
    /// The ID of the underlying job that the task related to
    /// </summary>
    [Newtonsoft.Json.JsonProperty("job_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Job_id { get; set; }

    /// <summary>
    /// The operation of the task
    /// </summary>
    [Newtonsoft.Json.JsonProperty("operation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Operation { get; set; }

    /// <summary>
    /// The type of the resource that the task operates
    /// </summary>
    [Newtonsoft.Json.JsonProperty("resource_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Resource_type { get; set; }

    /// <summary>
    /// The source resource that the task operates
    /// </summary>
    [Newtonsoft.Json.JsonProperty("src_resource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Src_resource { get; set; }

    /// <summary>
    /// The destination resource that the task operates
    /// </summary>
    [Newtonsoft.Json.JsonProperty("dst_resource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Dst_resource { get; set; }

    /// <summary>
    /// The start time of the task
    /// </summary>
    [Newtonsoft.Json.JsonProperty("start_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Start_time { get; set; }

    /// <summary>
    /// The end time of the task
    /// </summary>
    [Newtonsoft.Json.JsonProperty("end_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? End_time { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Robot
{
    /// <summary>
    /// The ID of the robot
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Id { get; set; }

    /// <summary>
    /// The name of the tag
    /// </summary>
    [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Name { get; set; }

    /// <summary>
    /// The description of the robot
    /// </summary>
    [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Description { get; set; }

    /// <summary>
    /// The secret of the robot
    /// </summary>
    [Newtonsoft.Json.JsonProperty("secret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Secret { get; set; }

    /// <summary>
    /// The level of the robot, project or system
    /// </summary>
    [Newtonsoft.Json.JsonProperty("level", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Level { get; set; }

    /// <summary>
    /// The duration of the robot in days
    /// </summary>
    [Newtonsoft.Json.JsonProperty("duration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Duration { get; set; }

    /// <summary>
    /// The editable status of the robot
    /// </summary>
    [Newtonsoft.Json.JsonProperty("editable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Editable { get; set; }

    /// <summary>
    /// The disable status of the robot
    /// </summary>
    [Newtonsoft.Json.JsonProperty("disable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Disable { get; set; }

    /// <summary>
    /// The expiration data of the robot
    /// </summary>
    [Newtonsoft.Json.JsonProperty("expires_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Expires_at { get; set; }

    [Newtonsoft.Json.JsonProperty("permissions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<RobotPermission> Permissions { get; set; }

    /// <summary>
    /// The creation time of the robot.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("creation_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Creation_time { get; set; }

    /// <summary>
    /// The update time of the robot.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("update_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Update_time { get; set; }

}

/// <summary>
/// The request for robot account creation.
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RobotCreate
{
    /// <summary>
    /// The name of the tag
    /// </summary>
    [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Name { get; set; }

    /// <summary>
    /// The description of the robot
    /// </summary>
    [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Description { get; set; }

    /// <summary>
    /// The secret of the robot
    /// </summary>
    [Newtonsoft.Json.JsonProperty("secret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Secret { get; set; }

    /// <summary>
    /// The level of the robot, project or system
    /// </summary>
    [Newtonsoft.Json.JsonProperty("level", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Level { get; set; }

    /// <summary>
    /// The disable status of the robot
    /// </summary>
    [Newtonsoft.Json.JsonProperty("disable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Disable { get; set; }

    /// <summary>
    /// The duration of the robot in days
    /// </summary>
    [Newtonsoft.Json.JsonProperty("duration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Duration { get; set; }

    [Newtonsoft.Json.JsonProperty("permissions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<RobotPermission> Permissions { get; set; }

}

/// <summary>
/// The response for robot account creation.
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RobotCreated
{
    /// <summary>
    /// The ID of the robot
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Id { get; set; }

    /// <summary>
    /// The name of the tag
    /// </summary>
    [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Name { get; set; }

    /// <summary>
    /// The secret of the robot
    /// </summary>
    [Newtonsoft.Json.JsonProperty("secret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Secret { get; set; }

    /// <summary>
    /// The creation time of the robot.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("creation_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Creation_time { get; set; }

    /// <summary>
    /// The expiration data of the robot
    /// </summary>
    [Newtonsoft.Json.JsonProperty("expires_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Expires_at { get; set; }

}

/// <summary>
/// The response for refresh/update robot account secret.
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RobotSec
{
    /// <summary>
    /// The secret of the robot
    /// </summary>
    [Newtonsoft.Json.JsonProperty("secret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Secret { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RobotPermission
{
    /// <summary>
    /// The kind of the permission
    /// </summary>
    [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Kind { get; set; }

    /// <summary>
    /// The namespace of the permission
    /// </summary>
    [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Namespace { get; set; }

    [Newtonsoft.Json.JsonProperty("access", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<Access> Access { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Access
{
    /// <summary>
    /// The resource of the access
    /// </summary>
    [Newtonsoft.Json.JsonProperty("resource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Resource { get; set; }

    /// <summary>
    /// The action of the access
    /// </summary>
    [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Action { get; set; }

    /// <summary>
    /// The effect of the access
    /// </summary>
    [Newtonsoft.Json.JsonProperty("effect", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Effect { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RobotCreateV1
{
    /// <summary>
    /// The name of robot account
    /// </summary>
    [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Name { get; set; }

    /// <summary>
    /// The description of robot account
    /// </summary>
    [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Description { get; set; }

    /// <summary>
    /// The expiration time on or after which the JWT MUST NOT be accepted for processing.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("expires_at", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Expires_at { get; set; }

    /// <summary>
    /// The permission of robot account
    /// </summary>
    [Newtonsoft.Json.JsonProperty("access", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<Access> Access { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Storage
{
    /// <summary>
    /// Total volume size.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Total { get; set; }

    /// <summary>
    /// Free volume size.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("free", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Free { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class GeneralInfo
{
    /// <summary>
    /// The current time of the server.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("current_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Current_time { get; set; }

    /// <summary>
    /// If the Harbor instance is deployed with nested notary.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("with_notary", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? With_notary { get; set; }

    /// <summary>
    /// If the Harbor instance is deployed with nested chartmuseum.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("with_chartmuseum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? With_chartmuseum { get; set; }

    /// <summary>
    /// The url of registry against which the docker command should be issued.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("registry_url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Registry_url { get; set; }

    /// <summary>
    /// The external URL of Harbor, with protocol.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("external_url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string External_url { get; set; }

    /// <summary>
    /// The auth mode of current Harbor instance.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("auth_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Auth_mode { get; set; }

    /// <summary>
    /// Indicate who can create projects, it could be 'adminonly' or 'everyone'.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("project_creation_restriction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Project_creation_restriction { get; set; }

    /// <summary>
    /// Indicate whether the Harbor instance enable user to register himself.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("self_registration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Self_registration { get; set; }

    /// <summary>
    /// Indicate whether there is a ca root cert file ready for download in the file system.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("has_ca_root", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Has_ca_root { get; set; }

    /// <summary>
    /// The build version of Harbor.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("harbor_version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Harbor_version { get; set; }

    /// <summary>
    /// The storage provider's name of Harbor registry
    /// </summary>
    [Newtonsoft.Json.JsonProperty("registry_storage_provider_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Registry_storage_provider_name { get; set; }

    /// <summary>
    /// The flag to indicate whether Harbor is in readonly mode.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("read_only", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Read_only { get; set; }

    /// <summary>
    /// The flag to indicate whether notification mechanism is enabled on Harbor instance.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("notification_enable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Notification_enable { get; set; }

    /// <summary>
    /// The setting of auth proxy this is only available when Harbor relies on authproxy for authentication.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("authproxy_settings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public AuthproxySetting Authproxy_settings { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class AuthproxySetting
{
    /// <summary>
    /// The fully qualified URI of login endpoint of authproxy, such as 'https://192.168.1.2:8443/login'
    /// </summary>
    [Newtonsoft.Json.JsonProperty("endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Endpoint { get; set; }

    /// <summary>
    /// The fully qualified URI of token review endpoint of authproxy, such as 'https://192.168.1.2:8443/tokenreview'
    /// </summary>
    [Newtonsoft.Json.JsonProperty("tokenreivew_endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Tokenreivew_endpoint { get; set; }

    /// <summary>
    /// The flag to determine whether Harbor can skip search the user/group when adding him as a member.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("skip_search", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Skip_search { get; set; }

    /// <summary>
    /// The flag to determine whether Harbor should verify the certificate when connecting to the auth proxy.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("verify_cert", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Verify_cert { get; set; }

    /// <summary>
    /// The certificate to be pinned when connecting auth proxy.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("server_certificate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Server_certificate { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class SystemInfo
{
    /// <summary>
    /// The storage of system.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("storage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<Storage> Storage { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class GCHistory
{
    /// <summary>
    /// the id of gc job.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Id { get; set; }

    /// <summary>
    /// the job name of gc job.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("job_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Job_name { get; set; }

    /// <summary>
    /// the job kind of gc job.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("job_kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Job_kind { get; set; }

    /// <summary>
    /// the job parameters of gc job.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("job_parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Job_parameters { get; set; }

    [Newtonsoft.Json.JsonProperty("schedule", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public ScheduleObj Schedule { get; set; }

    /// <summary>
    /// the status of gc job.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("job_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Job_status { get; set; }

    /// <summary>
    /// if gc job was deleted.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("deleted", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Deleted { get; set; }

    /// <summary>
    /// the creation time of gc job.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("creation_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Creation_time { get; set; }

    /// <summary>
    /// the update time of gc job.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("update_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Update_time { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ExecHistory
{
    /// <summary>
    /// the id of purge job.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Id { get; set; }

    /// <summary>
    /// the job name of purge job.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("job_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Job_name { get; set; }

    /// <summary>
    /// the job kind of purge job.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("job_kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Job_kind { get; set; }

    /// <summary>
    /// the job parameters of purge job.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("job_parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Job_parameters { get; set; }

    [Newtonsoft.Json.JsonProperty("schedule", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public ScheduleObj Schedule { get; set; }

    /// <summary>
    /// the status of purge job.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("job_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Job_status { get; set; }

    /// <summary>
    /// if purge job was deleted.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("deleted", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Deleted { get; set; }

    /// <summary>
    /// the creation time of purge job.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("creation_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Creation_time { get; set; }

    /// <summary>
    /// the update time of purge job.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("update_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Update_time { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Schedule
{
    /// <summary>
    /// The id of the schedule.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Id { get; set; }

    /// <summary>
    /// The status of the schedule.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Status { get; set; }

    /// <summary>
    /// the creation time of the schedule.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("creation_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Creation_time { get; set; }

    /// <summary>
    /// the update time of the schedule.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("update_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Update_time { get; set; }

    [Newtonsoft.Json.JsonProperty("schedule", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public ScheduleObj Schedule1 { get; set; }

    /// <summary>
    /// The parameters of schedule job
    /// </summary>
    [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.IDictionary<string, object> Parameters { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ScheduleObj
{
    /// <summary>
    /// The schedule type. The valid values are 'Hourly', 'Daily', 'Weekly', 'Custom', 'Manual' and 'None'.
    /// <br/>'Manual' means to trigger it right away and 'None' means to cancel the schedule.
    /// <br/>
    /// </summary>
    [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
    public ScheduleObjType? Type { get; set; }

    /// <summary>
    /// A cron expression, a time-based job scheduler.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("cron", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Cron { get; set; }

    /// <summary>
    /// The next time to schedule to run the job.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("next_scheduled_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Next_scheduled_time { get; set; }

}

/// <summary>
/// Stats provides the overall progress of the scan all process.
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Stats
{
    /// <summary>
    /// The total number of scan processes triggered by the scan all action
    /// </summary>
    [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Total { get; set; }

    /// <summary>
    /// The number of the finished scan processes triggered by the scan all action
    /// </summary>
    [Newtonsoft.Json.JsonProperty("completed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Completed { get; set; }

    /// <summary>
    /// The metrics data for the each status
    /// </summary>
    [Newtonsoft.Json.JsonProperty("metrics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.IDictionary<string, int> Metrics { get; set; }

    /// <summary>
    /// A flag indicating job status of scan all.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ongoing", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Ongoing { get; set; }

    /// <summary>
    /// The trigger of the scan all job.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("trigger", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
    public StatsTrigger? Trigger { get; set; }

}

/// <summary>
/// the tag retention metadata
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RetentionMetadata
{
    /// <summary>
    /// templates
    /// </summary>
    [Newtonsoft.Json.JsonProperty("templates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<RetentionRuleMetadata> Templates { get; set; }

    /// <summary>
    /// supported scope selectors
    /// </summary>
    [Newtonsoft.Json.JsonProperty("scope_selectors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<RetentionSelectorMetadata> Scope_selectors { get; set; }

    /// <summary>
    /// supported tag selectors
    /// </summary>
    [Newtonsoft.Json.JsonProperty("tag_selectors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<RetentionSelectorMetadata> Tag_selectors { get; set; }

}

/// <summary>
/// the tag retention rule metadata
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RetentionRuleMetadata
{
    /// <summary>
    /// rule id
    /// </summary>
    [Newtonsoft.Json.JsonProperty("rule_template", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Rule_template { get; set; }

    /// <summary>
    /// rule display text
    /// </summary>
    [Newtonsoft.Json.JsonProperty("display_text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Display_text { get; set; }

    /// <summary>
    /// rule action
    /// </summary>
    [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Action { get; set; }

    /// <summary>
    /// rule params
    /// </summary>
    [Newtonsoft.Json.JsonProperty("params", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<RetentionRuleParamMetadata> Params { get; set; }

}

/// <summary>
/// rule param
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RetentionRuleParamMetadata
{
    [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Type { get; set; }

    [Newtonsoft.Json.JsonProperty("unit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Unit { get; set; }

    [Newtonsoft.Json.JsonProperty("required", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Required { get; set; }

}

/// <summary>
/// retention selector
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RetentionSelectorMetadata
{
    [Newtonsoft.Json.JsonProperty("display_text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Display_text { get; set; }

    [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Kind { get; set; }

    [Newtonsoft.Json.JsonProperty("decorations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<string> Decorations { get; set; }

}

/// <summary>
/// retention policy
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RetentionPolicy
{
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Id { get; set; }

    [Newtonsoft.Json.JsonProperty("algorithm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Algorithm { get; set; }

    [Newtonsoft.Json.JsonProperty("rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<RetentionRule> Rules { get; set; }

    [Newtonsoft.Json.JsonProperty("trigger", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public RetentionRuleTrigger Trigger { get; set; }

    [Newtonsoft.Json.JsonProperty("scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public RetentionPolicyScope Scope { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RetentionRuleTrigger
{
    [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Kind { get; set; }

    [Newtonsoft.Json.JsonProperty("settings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public object Settings { get; set; }

    [Newtonsoft.Json.JsonProperty("references", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public object References { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RetentionPolicyScope
{
    [Newtonsoft.Json.JsonProperty("level", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Level { get; set; }

    [Newtonsoft.Json.JsonProperty("ref", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Ref { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RetentionRule
{
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Id { get; set; }

    [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Priority { get; set; }

    [Newtonsoft.Json.JsonProperty("disabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Disabled { get; set; }

    [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Action { get; set; }

    [Newtonsoft.Json.JsonProperty("template", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Template { get; set; }

    [Newtonsoft.Json.JsonProperty("params", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.IDictionary<string, object> Params { get; set; }

    [Newtonsoft.Json.JsonProperty("tag_selectors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<RetentionSelector> Tag_selectors { get; set; }

    [Newtonsoft.Json.JsonProperty("scope_selectors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<RetentionSelector>> Scope_selectors { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RetentionSelector
{
    [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Kind { get; set; }

    [Newtonsoft.Json.JsonProperty("decoration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Decoration { get; set; }

    [Newtonsoft.Json.JsonProperty("pattern", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Pattern { get; set; }

    [Newtonsoft.Json.JsonProperty("extras", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Extras { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RetentionExecution
{
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Id { get; set; }

    [Newtonsoft.Json.JsonProperty("policy_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Policy_id { get; set; }

    [Newtonsoft.Json.JsonProperty("start_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Start_time { get; set; }

    [Newtonsoft.Json.JsonProperty("end_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string End_time { get; set; }

    [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Status { get; set; }

    [Newtonsoft.Json.JsonProperty("trigger", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Trigger { get; set; }

    [Newtonsoft.Json.JsonProperty("dry_run", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Dry_run { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RetentionExecutionTask
{
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Id { get; set; }

    [Newtonsoft.Json.JsonProperty("execution_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Execution_id { get; set; }

    [Newtonsoft.Json.JsonProperty("repository", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Repository { get; set; }

    [Newtonsoft.Json.JsonProperty("job_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Job_id { get; set; }

    [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Status { get; set; }

    [Newtonsoft.Json.JsonProperty("status_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Status_code { get; set; }

    [Newtonsoft.Json.JsonProperty("status_revision", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Status_revision { get; set; }

    [Newtonsoft.Json.JsonProperty("start_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Start_time { get; set; }

    [Newtonsoft.Json.JsonProperty("end_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string End_time { get; set; }

    [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Total { get; set; }

    [Newtonsoft.Json.JsonProperty("retained", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Retained { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class QuotaUpdateReq
{
    /// <summary>
    /// The new hard limits for the quota
    /// </summary>
    [Newtonsoft.Json.JsonProperty("hard", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public ResourceList Hard { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class QuotaRefObject : System.Collections.Generic.Dictionary<string, object>
{

}

/// <summary>
/// The quota object
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Quota
{
    /// <summary>
    /// ID of the quota
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Id { get; set; }

    /// <summary>
    /// The reference object of the quota
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ref", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public QuotaRefObject Ref { get; set; }

    /// <summary>
    /// The hard limits of the quota
    /// </summary>
    [Newtonsoft.Json.JsonProperty("hard", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public ResourceList Hard { get; set; }

    /// <summary>
    /// The used status of the quota
    /// </summary>
    [Newtonsoft.Json.JsonProperty("used", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public ResourceList Used { get; set; }

    /// <summary>
    /// the creation time of the quota
    /// </summary>
    [Newtonsoft.Json.JsonProperty("creation_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Creation_time { get; set; }

    /// <summary>
    /// the update time of the quota
    /// </summary>
    [Newtonsoft.Json.JsonProperty("update_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Update_time { get; set; }

}

/// <summary>
/// Registration represents a named configuration for invoking a scanner via its adapter.
/// <br/>
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ScannerRegistration
{
    /// <summary>
    /// The unique identifier of this registration.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("uuid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Uuid { get; set; }

    /// <summary>
    /// The name of this registration.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Name { get; set; }

    /// <summary>
    /// An optional description of this registration.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Description { get; set; }

    /// <summary>
    /// A base URL of the scanner adapter
    /// </summary>
    [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Url { get; set; }

    /// <summary>
    /// Indicate whether the registration is enabled or not
    /// </summary>
    [Newtonsoft.Json.JsonProperty("disabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Disabled { get; set; } = false;

    /// <summary>
    /// Indicate if the registration is set as the system default one
    /// </summary>
    [Newtonsoft.Json.JsonProperty("is_default", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Is_default { get; set; } = false;

    /// <summary>
    /// Specify what authentication approach is adopted for the HTTP communications.
    /// <br/>Supported types Basic", "Bearer" and api key header "X-ScannerAdapter-API-Key"
    /// <br/>
    /// </summary>
    [Newtonsoft.Json.JsonProperty("auth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Auth { get; set; } = "";

    /// <summary>
    /// An optional value of the HTTP Authorization header sent with each request to the Scanner Adapter API.
    /// <br/>
    /// </summary>
    [Newtonsoft.Json.JsonProperty("access_credential", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Access_credential { get; set; }

    /// <summary>
    /// Indicate if skip the certificate verification when sending HTTP requests
    /// </summary>
    [Newtonsoft.Json.JsonProperty("skip_certVerify", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Skip_certVerify { get; set; } = false;

    /// <summary>
    /// Indicate whether use internal registry addr for the scanner to pull content or not
    /// </summary>
    [Newtonsoft.Json.JsonProperty("use_internal_addr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Use_internal_addr { get; set; } = false;

    /// <summary>
    /// The creation time of this registration
    /// </summary>
    [Newtonsoft.Json.JsonProperty("create_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Create_time { get; set; }

    /// <summary>
    /// The update time of this registration
    /// </summary>
    [Newtonsoft.Json.JsonProperty("update_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Update_time { get; set; }

    /// <summary>
    /// Optional property to describe the name of the scanner registration
    /// </summary>
    [Newtonsoft.Json.JsonProperty("adapter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Adapter { get; set; }

    /// <summary>
    /// Optional property to describe the vendor of the scanner registration
    /// </summary>
    [Newtonsoft.Json.JsonProperty("vendor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Vendor { get; set; }

    /// <summary>
    /// Optional property to describe the version of the scanner registration
    /// </summary>
    [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Version { get; set; }

    /// <summary>
    /// Indicate the healthy of the registration
    /// </summary>
    [Newtonsoft.Json.JsonProperty("health", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Health { get; set; } = "";

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ScannerRegistrationReq
{
    /// <summary>
    /// The name of this registration
    /// </summary>
    [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    public string Name { get; set; }

    /// <summary>
    /// An optional description of this registration.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Description { get; set; }

    /// <summary>
    /// A base URL of the scanner adapter.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Always)]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    public System.Uri Url { get; set; }

    /// <summary>
    /// Specify what authentication approach is adopted for the HTTP communications.
    /// <br/>Supported types Basic", "Bearer" and api key header "X-ScannerAdapter-API-Key"
    /// <br/>
    /// </summary>
    [Newtonsoft.Json.JsonProperty("auth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Auth { get; set; }

    /// <summary>
    /// An optional value of the HTTP Authorization header sent with each request to the Scanner Adapter API.
    /// <br/>
    /// </summary>
    [Newtonsoft.Json.JsonProperty("access_credential", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Access_credential { get; set; }

    /// <summary>
    /// Indicate if skip the certificate verification when sending HTTP requests
    /// </summary>
    [Newtonsoft.Json.JsonProperty("skip_certVerify", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Skip_certVerify { get; set; } = false;

    /// <summary>
    /// Indicate whether use internal registry addr for the scanner to pull content or not
    /// </summary>
    [Newtonsoft.Json.JsonProperty("use_internal_addr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Use_internal_addr { get; set; } = false;

    /// <summary>
    /// Indicate whether the registration is enabled or not
    /// </summary>
    [Newtonsoft.Json.JsonProperty("disabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Disabled { get; set; } = false;

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ScannerRegistrationSettings
{
    /// <summary>
    /// The name of this registration
    /// </summary>
    [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    public string Name { get; set; }

    /// <summary>
    /// A base URL of the scanner adapter.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Always)]
    [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
    public System.Uri Url { get; set; }

    /// <summary>
    /// Specify what authentication approach is adopted for the HTTP communications.
    /// <br/>Supported types Basic", "Bearer" and api key header "X-ScannerAdapter-API-Key"
    /// <br/>
    /// </summary>
    [Newtonsoft.Json.JsonProperty("auth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Auth { get; set; } = "";

    /// <summary>
    /// An optional value of the HTTP Authorization header sent with each request to the Scanner Adapter API.
    /// <br/>
    /// </summary>
    [Newtonsoft.Json.JsonProperty("access_credential", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Access_credential { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class IsDefault
{
    /// <summary>
    /// A flag indicating whether a scanner registration is default.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("is_default", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Is_default { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ScannerCapability
{
    [Newtonsoft.Json.JsonProperty("consumes_mime_types", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<string> Consumes_mime_types { get; set; }

    [Newtonsoft.Json.JsonProperty("produces_mime_types", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<string> Produces_mime_types { get; set; }

}

/// <summary>
/// The metadata info of the scanner adapter
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ScannerAdapterMetadata
{
    [Newtonsoft.Json.JsonProperty("scanner", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public Scanner Scanner { get; set; }

    [Newtonsoft.Json.JsonProperty("capabilities", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<ScannerCapability> Capabilities { get; set; }

    [Newtonsoft.Json.JsonProperty("properties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.IDictionary<string, string> Properties { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ImmutableRule
{
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Id { get; set; }

    [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Priority { get; set; }

    [Newtonsoft.Json.JsonProperty("disabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Disabled { get; set; }

    [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Action { get; set; }

    [Newtonsoft.Json.JsonProperty("template", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Template { get; set; }

    [Newtonsoft.Json.JsonProperty("params", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.IDictionary<string, object> Params { get; set; }

    [Newtonsoft.Json.JsonProperty("tag_selectors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<ImmutableSelector> Tag_selectors { get; set; }

    [Newtonsoft.Json.JsonProperty("scope_selectors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<ImmutableSelector>> Scope_selectors { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ImmutableSelector
{
    [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Kind { get; set; }

    [Newtonsoft.Json.JsonProperty("decoration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Decoration { get; set; }

    [Newtonsoft.Json.JsonProperty("pattern", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Pattern { get; set; }

    [Newtonsoft.Json.JsonProperty("extras", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Extras { get; set; }

}

/// <summary>
/// The ldap configure properties
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class LdapConf
{
    /// <summary>
    /// The url of ldap service.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Ldap_url { get; set; }

    /// <summary>
    /// The search dn of ldap service.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_search_dn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Ldap_search_dn { get; set; }

    /// <summary>
    /// The search password of ldap service.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_search_password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Ldap_search_password { get; set; }

    /// <summary>
    /// The base dn of ldap service.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_base_dn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Ldap_base_dn { get; set; }

    /// <summary>
    /// The serach filter of ldap service.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Ldap_filter { get; set; }

    /// <summary>
    /// The serach uid from ldap service attributes.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_uid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Ldap_uid { get; set; }

    /// <summary>
    /// The serach scope of ldap service.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Ldap_scope { get; set; }

    /// <summary>
    /// The connect timeout of ldap service(second).
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_connection_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Ldap_connection_timeout { get; set; }

    /// <summary>
    /// Verify Ldap server certificate.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_verify_cert", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Ldap_verify_cert { get; set; }

}

/// <summary>
/// The ldap ping result
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class LdapPingResult
{
    /// <summary>
    /// Test success
    /// </summary>
    [Newtonsoft.Json.JsonProperty("success", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Success { get; set; }

    /// <summary>
    /// The ping operation output message.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Message { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class LdapImportUsers
{
    /// <summary>
    /// selected uid list
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_uid_list", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<string> Ldap_uid_list { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class LdapFailedImportUser
{
    /// <summary>
    /// the uid can't add to system.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("uid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Uid { get; set; }

    /// <summary>
    /// fail reason.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Error { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class LdapUser
{
    /// <summary>
    /// ldap username.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Username { get; set; }

    /// <summary>
    /// The user realname from "uid" or "cn" attribute.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("realname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Realname { get; set; }

    /// <summary>
    /// The user email address from "mail" or "email" attribute.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("email", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Email { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class UserGroup
{
    /// <summary>
    /// The ID of the user group
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Id { get; set; }

    /// <summary>
    /// The name of the user group
    /// </summary>
    [Newtonsoft.Json.JsonProperty("group_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Group_name { get; set; }

    /// <summary>
    /// The group type, 1 for LDAP group, 2 for HTTP group, 3 for OIDC group.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("group_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Group_type { get; set; }

    /// <summary>
    /// The DN of the LDAP group if group type is 1 (LDAP group).
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_group_dn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Ldap_group_dn { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class UserGroupSearchItem
{
    /// <summary>
    /// The ID of the user group
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Id { get; set; }

    /// <summary>
    /// The name of the user group
    /// </summary>
    [Newtonsoft.Json.JsonProperty("group_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Group_name { get; set; }

    /// <summary>
    /// The group type, 1 for LDAP group, 2 for HTTP group, 3 for OIDC group.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("group_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Group_type { get; set; }

}

/// <summary>
/// Supportted webhook event types and notify types.
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class SupportedWebhookEventTypes
{
    [Newtonsoft.Json.JsonProperty("event_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<string> Event_type { get; set; }

    [Newtonsoft.Json.JsonProperty("notify_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<string> Notify_type { get; set; }

}

/// <summary>
/// The webhook policy target object.
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class WebhookTargetObject
{
    /// <summary>
    /// The webhook target notify type.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Type { get; set; }

    /// <summary>
    /// The webhook target address.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Address { get; set; }

    /// <summary>
    /// The webhook auth header.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("auth_header", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Auth_header { get; set; }

    /// <summary>
    /// Whether or not to skip cert verify.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("skip_cert_verify", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Skip_cert_verify { get; set; }

}

/// <summary>
/// The webhook policy object
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class WebhookPolicy
{
    /// <summary>
    /// The webhook policy ID.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Id { get; set; }

    /// <summary>
    /// The name of webhook policy.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Name { get; set; }

    /// <summary>
    /// The description of webhook policy.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Description { get; set; }

    /// <summary>
    /// The project ID of webhook policy.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("project_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Project_id { get; set; }

    [Newtonsoft.Json.JsonProperty("targets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<WebhookTargetObject> Targets { get; set; }

    [Newtonsoft.Json.JsonProperty("event_types", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<string> Event_types { get; set; }

    /// <summary>
    /// The creator of the webhook policy.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("creator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Creator { get; set; }

    /// <summary>
    /// The create time of the webhook policy.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("creation_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Creation_time { get; set; }

    /// <summary>
    /// The update time of the webhook policy.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("update_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Update_time { get; set; }

    /// <summary>
    /// Whether the webhook policy is enabled or not.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Enabled { get; set; }

}

/// <summary>
/// The webhook policy and last trigger time group by event type.
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class WebhookLastTrigger
{
    /// <summary>
    /// The webhook policy name.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("policy_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Policy_name { get; set; }

    /// <summary>
    /// The webhook event type.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("event_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Event_type { get; set; }

    /// <summary>
    /// Whether or not the webhook policy enabled.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Enabled { get; set; }

    /// <summary>
    /// The creation time of webhook policy.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("creation_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Creation_time { get; set; }

    /// <summary>
    /// The last trigger time of webhook policy.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("last_trigger_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Last_trigger_time { get; set; }

}

/// <summary>
/// The webhook job.
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class WebhookJob
{
    /// <summary>
    /// The webhook job ID.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Id { get; set; }

    /// <summary>
    /// The webhook policy ID.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("policy_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Policy_id { get; set; }

    /// <summary>
    /// The webhook job event type.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("event_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Event_type { get; set; }

    /// <summary>
    /// The webhook job notify type.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("notify_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Notify_type { get; set; }

    /// <summary>
    /// The webhook job status.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Status { get; set; }

    /// <summary>
    /// The webhook job notify detailed data.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("job_detail", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Job_detail { get; set; }

    /// <summary>
    /// The webhook job creation time.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("creation_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Creation_time { get; set; }

    /// <summary>
    /// The webhook job update time.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("update_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Update_time { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class InternalConfigurationsResponse : System.Collections.Generic.Dictionary<string, InternalConfigurationValue>
{

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class InternalConfigurationValue
{
    /// <summary>
    /// The value of current config item
    /// </summary>
    [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public object Value { get; set; }

    /// <summary>
    /// The configure item can be updated or not
    /// </summary>
    [Newtonsoft.Json.JsonProperty("editable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Editable { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ConfigurationsResponse
{
    /// <summary>
    /// The auth mode of current system, such as "db_auth", "ldap_auth", "oidc_auth"
    /// </summary>
    [Newtonsoft.Json.JsonProperty("auth_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Auth_mode { get; set; }

    /// <summary>
    /// The sender name for Email notification.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("email_from", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Email_from { get; set; }

    /// <summary>
    /// The hostname of SMTP server that sends Email notification.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("email_host", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Email_host { get; set; }

    /// <summary>
    /// By default it's empty so the email_username is picked
    /// </summary>
    [Newtonsoft.Json.JsonProperty("email_identity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Email_identity { get; set; }

    /// <summary>
    /// Whether or not the certificate will be verified when Harbor tries to access the email server.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("email_insecure", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public BoolConfigItem Email_insecure { get; set; }

    /// <summary>
    /// The port of SMTP server
    /// </summary>
    [Newtonsoft.Json.JsonProperty("email_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public IntegerConfigItem Email_port { get; set; }

    /// <summary>
    /// When it''s set to true the system will access Email server via TLS by default.  If it''s set to false, it still will handle "STARTTLS" from server side.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("email_ssl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public BoolConfigItem Email_ssl { get; set; }

    /// <summary>
    /// The username for authenticate against SMTP server
    /// </summary>
    [Newtonsoft.Json.JsonProperty("email_username", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Email_username { get; set; }

    /// <summary>
    /// The Base DN for LDAP binding.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_base_dn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Ldap_base_dn { get; set; }

    /// <summary>
    /// The filter for LDAP search
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Ldap_filter { get; set; }

    /// <summary>
    /// The base DN to search LDAP group.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_group_base_dn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Ldap_group_base_dn { get; set; }

    /// <summary>
    /// Specify the ldap group which have the same privilege with Harbor admin
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_group_admin_dn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Ldap_group_admin_dn { get; set; }

    /// <summary>
    /// The attribute which is used as identity of the LDAP group, default is cn.'
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_group_attribute_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Ldap_group_attribute_name { get; set; }

    /// <summary>
    /// The filter to search the ldap group
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_group_search_filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Ldap_group_search_filter { get; set; }

    /// <summary>
    /// The scope to search ldap group. ''0-LDAP_SCOPE_BASE, 1-LDAP_SCOPE_ONELEVEL, 2-LDAP_SCOPE_SUBTREE''
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_group_search_scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public IntegerConfigItem Ldap_group_search_scope { get; set; }

    /// <summary>
    /// The scope to search ldap users,'0-LDAP_SCOPE_BASE, 1-LDAP_SCOPE_ONELEVEL, 2-LDAP_SCOPE_SUBTREE'
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public IntegerConfigItem Ldap_scope { get; set; }

    /// <summary>
    /// The DN of the user to do the search.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_search_dn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Ldap_search_dn { get; set; }

    /// <summary>
    /// Timeout in seconds for connection to LDAP server
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public IntegerConfigItem Ldap_timeout { get; set; }

    /// <summary>
    /// The attribute which is used as identity for the LDAP binding, such as "CN" or "SAMAccountname"
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_uid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Ldap_uid { get; set; }

    /// <summary>
    /// The URL of LDAP server
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Ldap_url { get; set; }

    /// <summary>
    /// Whether verify your OIDC server certificate, disable it if your OIDC server is hosted via self-hosted certificate.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_verify_cert", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public BoolConfigItem Ldap_verify_cert { get; set; }

    /// <summary>
    /// The user attribute to identify the group membership
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_group_membership_attribute", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Ldap_group_membership_attribute { get; set; }

    /// <summary>
    /// Indicate who can create projects, it could be ''adminonly'' or ''everyone''.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("project_creation_restriction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Project_creation_restriction { get; set; }

    /// <summary>
    /// The flag to indicate whether Harbor is in readonly mode.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("read_only", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public BoolConfigItem Read_only { get; set; }

    /// <summary>
    /// Whether the Harbor instance supports self-registration.  If it''s set to false, admin need to add user to the instance.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("self_registration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public BoolConfigItem Self_registration { get; set; }

    /// <summary>
    /// The expiration time of the token for internal Registry, in minutes.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("token_expiration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public IntegerConfigItem Token_expiration { get; set; }

    /// <summary>
    /// The client id of UAA
    /// </summary>
    [Newtonsoft.Json.JsonProperty("uaa_client_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Uaa_client_id { get; set; }

    /// <summary>
    /// The client secret of the UAA
    /// </summary>
    [Newtonsoft.Json.JsonProperty("uaa_client_secret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Uaa_client_secret { get; set; }

    /// <summary>
    /// The endpoint of the UAA
    /// </summary>
    [Newtonsoft.Json.JsonProperty("uaa_endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Uaa_endpoint { get; set; }

    /// <summary>
    /// Verify the certificate in UAA server
    /// </summary>
    [Newtonsoft.Json.JsonProperty("uaa_verify_cert", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public BoolConfigItem Uaa_verify_cert { get; set; }

    /// <summary>
    /// The endpoint of the HTTP auth
    /// </summary>
    [Newtonsoft.Json.JsonProperty("http_authproxy_endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Http_authproxy_endpoint { get; set; }

    /// <summary>
    /// The token review endpoint
    /// </summary>
    [Newtonsoft.Json.JsonProperty("http_authproxy_tokenreview_endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Http_authproxy_tokenreview_endpoint { get; set; }

    /// <summary>
    /// The group which has the harbor admin privileges
    /// </summary>
    [Newtonsoft.Json.JsonProperty("http_authproxy_admin_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Http_authproxy_admin_groups { get; set; }

    /// <summary>
    /// The usernames which has the harbor admin privileges
    /// </summary>
    [Newtonsoft.Json.JsonProperty("http_authproxy_admin_usernames", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Http_authproxy_admin_usernames { get; set; }

    /// <summary>
    /// Verify the HTTP auth provider's certificate
    /// </summary>
    [Newtonsoft.Json.JsonProperty("http_authproxy_verify_cert", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public BoolConfigItem Http_authproxy_verify_cert { get; set; }

    /// <summary>
    /// Search user before onboard
    /// </summary>
    [Newtonsoft.Json.JsonProperty("http_authproxy_skip_search", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public BoolConfigItem Http_authproxy_skip_search { get; set; }

    /// <summary>
    /// The certificate of the HTTP auth provider
    /// </summary>
    [Newtonsoft.Json.JsonProperty("http_authproxy_server_certificate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Http_authproxy_server_certificate { get; set; }

    /// <summary>
    /// The OIDC provider name
    /// </summary>
    [Newtonsoft.Json.JsonProperty("oidc_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Oidc_name { get; set; }

    /// <summary>
    /// The endpoint of the OIDC provider
    /// </summary>
    [Newtonsoft.Json.JsonProperty("oidc_endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Oidc_endpoint { get; set; }

    /// <summary>
    /// The client ID of the OIDC provider
    /// </summary>
    [Newtonsoft.Json.JsonProperty("oidc_client_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Oidc_client_id { get; set; }

    /// <summary>
    /// The attribute claims the group name
    /// </summary>
    [Newtonsoft.Json.JsonProperty("oidc_groups_claim", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Oidc_groups_claim { get; set; }

    /// <summary>
    /// The OIDC group which has the harbor admin privileges
    /// </summary>
    [Newtonsoft.Json.JsonProperty("oidc_admin_group", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Oidc_admin_group { get; set; }

    /// <summary>
    /// The scope of the OIDC provider
    /// </summary>
    [Newtonsoft.Json.JsonProperty("oidc_scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Oidc_scope { get; set; }

    /// <summary>
    /// The attribute claims the username
    /// </summary>
    [Newtonsoft.Json.JsonProperty("oidc_user_claim", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Oidc_user_claim { get; set; }

    /// <summary>
    /// Verify the OIDC provider's certificate'
    /// </summary>
    [Newtonsoft.Json.JsonProperty("oidc_verify_cert", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public BoolConfigItem Oidc_verify_cert { get; set; }

    /// <summary>
    /// Auto onboard the OIDC user
    /// </summary>
    [Newtonsoft.Json.JsonProperty("oidc_auto_onboard", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public BoolConfigItem Oidc_auto_onboard { get; set; }

    /// <summary>
    /// Extra parameters to add when redirect request to OIDC provider
    /// </summary>
    [Newtonsoft.Json.JsonProperty("oidc_extra_redirect_parms", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Oidc_extra_redirect_parms { get; set; }

    /// <summary>
    /// The robot account token duration in days
    /// </summary>
    [Newtonsoft.Json.JsonProperty("robot_token_duration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public IntegerConfigItem Robot_token_duration { get; set; }

    /// <summary>
    /// The rebot account name prefix
    /// </summary>
    [Newtonsoft.Json.JsonProperty("robot_name_prefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Robot_name_prefix { get; set; }

    /// <summary>
    /// Enable notification
    /// </summary>
    [Newtonsoft.Json.JsonProperty("notification_enable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public BoolConfigItem Notification_enable { get; set; }

    /// <summary>
    /// Enable quota per project
    /// </summary>
    [Newtonsoft.Json.JsonProperty("quota_per_project_enable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public BoolConfigItem Quota_per_project_enable { get; set; }

    /// <summary>
    /// The storage quota per project
    /// </summary>
    [Newtonsoft.Json.JsonProperty("storage_per_project", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public IntegerConfigItem Storage_per_project { get; set; }

    /// <summary>
    /// The endpoint of the audit log forwarder
    /// </summary>
    [Newtonsoft.Json.JsonProperty("audit_log_forward_endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public StringConfigItem Audit_log_forward_endpoint { get; set; }

    /// <summary>
    /// Whether skip the audit log in database
    /// </summary>
    [Newtonsoft.Json.JsonProperty("skip_audit_log_database", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public BoolConfigItem Skip_audit_log_database { get; set; }

    [Newtonsoft.Json.JsonProperty("scan_all_policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public Scan_all_policy Scan_all_policy { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Configurations
{
    /// <summary>
    /// The auth mode of current system, such as "db_auth", "ldap_auth", "oidc_auth"
    /// </summary>
    [Newtonsoft.Json.JsonProperty("auth_mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Auth_mode { get; set; }

    /// <summary>
    /// The sender name for Email notification.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("email_from", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Email_from { get; set; }

    /// <summary>
    /// The hostname of SMTP server that sends Email notification.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("email_host", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Email_host { get; set; }

    /// <summary>
    /// By default it's empty so the email_username is picked
    /// </summary>
    [Newtonsoft.Json.JsonProperty("email_identity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Email_identity { get; set; }

    /// <summary>
    /// Whether or not the certificate will be verified when Harbor tries to access the email server.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("email_insecure", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Email_insecure { get; set; }

    /// <summary>
    /// Email password
    /// </summary>
    [Newtonsoft.Json.JsonProperty("email_password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Email_password { get; set; }

    /// <summary>
    /// The port of SMTP server
    /// </summary>
    [Newtonsoft.Json.JsonProperty("email_port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Email_port { get; set; }

    /// <summary>
    /// When it''s set to true the system will access Email server via TLS by default.  If it''s set to false, it still will handle "STARTTLS" from server side.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("email_ssl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Email_ssl { get; set; }

    /// <summary>
    /// The username for authenticate against SMTP server
    /// </summary>
    [Newtonsoft.Json.JsonProperty("email_username", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Email_username { get; set; }

    /// <summary>
    /// The Base DN for LDAP binding.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_base_dn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Ldap_base_dn { get; set; }

    /// <summary>
    /// The filter for LDAP search
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Ldap_filter { get; set; }

    /// <summary>
    /// The base DN to search LDAP group.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_group_base_dn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Ldap_group_base_dn { get; set; }

    /// <summary>
    /// Specify the ldap group which have the same privilege with Harbor admin
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_group_admin_dn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Ldap_group_admin_dn { get; set; }

    /// <summary>
    /// The attribute which is used as identity of the LDAP group, default is cn.'
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_group_attribute_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Ldap_group_attribute_name { get; set; }

    /// <summary>
    /// The filter to search the ldap group
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_group_search_filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Ldap_group_search_filter { get; set; }

    /// <summary>
    /// The scope to search ldap group. ''0-LDAP_SCOPE_BASE, 1-LDAP_SCOPE_ONELEVEL, 2-LDAP_SCOPE_SUBTREE''
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_group_search_scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Ldap_group_search_scope { get; set; }

    /// <summary>
    /// The scope to search ldap users,'0-LDAP_SCOPE_BASE, 1-LDAP_SCOPE_ONELEVEL, 2-LDAP_SCOPE_SUBTREE'
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Ldap_scope { get; set; }

    /// <summary>
    /// The DN of the user to do the search.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_search_dn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Ldap_search_dn { get; set; }

    /// <summary>
    /// The password of the ldap search dn
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_search_password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Ldap_search_password { get; set; }

    /// <summary>
    /// Timeout in seconds for connection to LDAP server
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Ldap_timeout { get; set; }

    /// <summary>
    /// The attribute which is used as identity for the LDAP binding, such as "CN" or "SAMAccountname"
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_uid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Ldap_uid { get; set; }

    /// <summary>
    /// The URL of LDAP server
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Ldap_url { get; set; }

    /// <summary>
    /// Whether verify your OIDC server certificate, disable it if your OIDC server is hosted via self-hosted certificate.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_verify_cert", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Ldap_verify_cert { get; set; }

    /// <summary>
    /// The user attribute to identify the group membership
    /// </summary>
    [Newtonsoft.Json.JsonProperty("ldap_group_membership_attribute", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Ldap_group_membership_attribute { get; set; }

    /// <summary>
    /// Indicate who can create projects, it could be ''adminonly'' or ''everyone''.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("project_creation_restriction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Project_creation_restriction { get; set; }

    /// <summary>
    /// The flag to indicate whether Harbor is in readonly mode.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("read_only", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Read_only { get; set; }

    /// <summary>
    /// Whether the Harbor instance supports self-registration.  If it''s set to false, admin need to add user to the instance.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("self_registration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Self_registration { get; set; }

    /// <summary>
    /// The expiration time of the token for internal Registry, in minutes.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("token_expiration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Token_expiration { get; set; }

    /// <summary>
    /// The client id of UAA
    /// </summary>
    [Newtonsoft.Json.JsonProperty("uaa_client_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Uaa_client_id { get; set; }

    /// <summary>
    /// The client secret of the UAA
    /// </summary>
    [Newtonsoft.Json.JsonProperty("uaa_client_secret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Uaa_client_secret { get; set; }

    /// <summary>
    /// The endpoint of the UAA
    /// </summary>
    [Newtonsoft.Json.JsonProperty("uaa_endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Uaa_endpoint { get; set; }

    /// <summary>
    /// Verify the certificate in UAA server
    /// </summary>
    [Newtonsoft.Json.JsonProperty("uaa_verify_cert", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Uaa_verify_cert { get; set; }

    /// <summary>
    /// The endpoint of the HTTP auth
    /// </summary>
    [Newtonsoft.Json.JsonProperty("http_authproxy_endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Http_authproxy_endpoint { get; set; }

    /// <summary>
    /// The token review endpoint
    /// </summary>
    [Newtonsoft.Json.JsonProperty("http_authproxy_tokenreview_endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Http_authproxy_tokenreview_endpoint { get; set; }

    /// <summary>
    /// The group which has the harbor admin privileges
    /// </summary>
    [Newtonsoft.Json.JsonProperty("http_authproxy_admin_groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Http_authproxy_admin_groups { get; set; }

    /// <summary>
    /// The username which has the harbor admin privileges
    /// </summary>
    [Newtonsoft.Json.JsonProperty("http_authproxy_admin_usernames", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Http_authproxy_admin_usernames { get; set; }

    /// <summary>
    /// Verify the HTTP auth provider's certificate
    /// </summary>
    [Newtonsoft.Json.JsonProperty("http_authproxy_verify_cert", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Http_authproxy_verify_cert { get; set; }

    /// <summary>
    /// Search user before onboard
    /// </summary>
    [Newtonsoft.Json.JsonProperty("http_authproxy_skip_search", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Http_authproxy_skip_search { get; set; }

    /// <summary>
    /// The certificate of the HTTP auth provider
    /// </summary>
    [Newtonsoft.Json.JsonProperty("http_authproxy_server_certificate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Http_authproxy_server_certificate { get; set; }

    /// <summary>
    /// The OIDC provider name
    /// </summary>
    [Newtonsoft.Json.JsonProperty("oidc_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Oidc_name { get; set; }

    /// <summary>
    /// The endpoint of the OIDC provider
    /// </summary>
    [Newtonsoft.Json.JsonProperty("oidc_endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Oidc_endpoint { get; set; }

    /// <summary>
    /// The client ID of the OIDC provider
    /// </summary>
    [Newtonsoft.Json.JsonProperty("oidc_client_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Oidc_client_id { get; set; }

    /// <summary>
    /// The OIDC provider secret
    /// </summary>
    [Newtonsoft.Json.JsonProperty("oidc_client_secret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Oidc_client_secret { get; set; }

    /// <summary>
    /// The attribute claims the group name
    /// </summary>
    [Newtonsoft.Json.JsonProperty("oidc_groups_claim", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Oidc_groups_claim { get; set; }

    /// <summary>
    /// The OIDC group which has the harbor admin privileges
    /// </summary>
    [Newtonsoft.Json.JsonProperty("oidc_admin_group", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Oidc_admin_group { get; set; }

    /// <summary>
    /// The scope of the OIDC provider
    /// </summary>
    [Newtonsoft.Json.JsonProperty("oidc_scope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Oidc_scope { get; set; }

    /// <summary>
    /// The attribute claims the username
    /// </summary>
    [Newtonsoft.Json.JsonProperty("oidc_user_claim", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Oidc_user_claim { get; set; }

    /// <summary>
    /// Verify the OIDC provider's certificate'
    /// </summary>
    [Newtonsoft.Json.JsonProperty("oidc_verify_cert", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Oidc_verify_cert { get; set; }

    /// <summary>
    /// Auto onboard the OIDC user
    /// </summary>
    [Newtonsoft.Json.JsonProperty("oidc_auto_onboard", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Oidc_auto_onboard { get; set; }

    /// <summary>
    /// Extra parameters to add when redirect request to OIDC provider
    /// </summary>
    [Newtonsoft.Json.JsonProperty("oidc_extra_redirect_parms", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Oidc_extra_redirect_parms { get; set; }

    /// <summary>
    /// The robot account token duration in days
    /// </summary>
    [Newtonsoft.Json.JsonProperty("robot_token_duration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Robot_token_duration { get; set; }

    /// <summary>
    /// The rebot account name prefix
    /// </summary>
    [Newtonsoft.Json.JsonProperty("robot_name_prefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Robot_name_prefix { get; set; }

    /// <summary>
    /// Enable notification
    /// </summary>
    [Newtonsoft.Json.JsonProperty("notification_enable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Notification_enable { get; set; }

    /// <summary>
    /// Enable quota per project
    /// </summary>
    [Newtonsoft.Json.JsonProperty("quota_per_project_enable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Quota_per_project_enable { get; set; }

    /// <summary>
    /// The storage quota per project
    /// </summary>
    [Newtonsoft.Json.JsonProperty("storage_per_project", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Storage_per_project { get; set; }

    /// <summary>
    /// The audit log forward endpoint
    /// </summary>
    [Newtonsoft.Json.JsonProperty("audit_log_forward_endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Audit_log_forward_endpoint { get; set; }

    /// <summary>
    /// Skip audit log database
    /// </summary>
    [Newtonsoft.Json.JsonProperty("skip_audit_log_database", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Skip_audit_log_database { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class StringConfigItem
{
    /// <summary>
    /// The string value of current config item
    /// </summary>
    [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Value { get; set; }

    /// <summary>
    /// The configure item can be updated or not
    /// </summary>
    [Newtonsoft.Json.JsonProperty("editable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Editable { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class BoolConfigItem
{
    /// <summary>
    /// The boolean value of current config item
    /// </summary>
    [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Value { get; set; }

    /// <summary>
    /// The configure item can be updated or not
    /// </summary>
    [Newtonsoft.Json.JsonProperty("editable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Editable { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class IntegerConfigItem
{
    /// <summary>
    /// The integer value of current config item
    /// </summary>
    [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Value { get; set; }

    /// <summary>
    /// The configure item can be updated or not
    /// </summary>
    [Newtonsoft.Json.JsonProperty("editable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Editable { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ProjectMemberEntity
{
    /// <summary>
    /// the project member id
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Id { get; set; }

    /// <summary>
    /// the project id
    /// </summary>
    [Newtonsoft.Json.JsonProperty("project_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Project_id { get; set; }

    /// <summary>
    /// the name of the group member.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("entity_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Entity_name { get; set; }

    /// <summary>
    /// the name of the role
    /// </summary>
    [Newtonsoft.Json.JsonProperty("role_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Role_name { get; set; }

    /// <summary>
    /// the role id
    /// </summary>
    [Newtonsoft.Json.JsonProperty("role_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Role_id { get; set; }

    /// <summary>
    /// the id of entity, if the member is a user, it is user_id in user table. if the member is a user group, it is the user group's ID in user_group table.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("entity_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Entity_id { get; set; }

    /// <summary>
    /// the entity's type, u for user entity, g for group entity.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("entity_type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Entity_type { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ProjectMember
{
    /// <summary>
    /// The role id 1 for projectAdmin, 2 for developer, 3 for guest, 4 for maintainer
    /// </summary>
    [Newtonsoft.Json.JsonProperty("role_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Role_id { get; set; }

    [Newtonsoft.Json.JsonProperty("member_user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public UserEntity Member_user { get; set; }

    [Newtonsoft.Json.JsonProperty("member_group", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public UserGroup Member_group { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class RoleRequest
{
    /// <summary>
    /// The role id 1 for projectAdmin, 2 for developer, 3 for guest, 4 for maintainer
    /// </summary>
    [Newtonsoft.Json.JsonProperty("role_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Role_id { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class UserEntity
{
    /// <summary>
    /// The ID of the user.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("user_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? User_id { get; set; }

    /// <summary>
    /// The name of the user.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Username { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class UserProfile
{
    [Newtonsoft.Json.JsonProperty("email", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Email { get; set; }

    [Newtonsoft.Json.JsonProperty("realname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Realname { get; set; }

    [Newtonsoft.Json.JsonProperty("comment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Comment { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class UserCreationReq
{
    [Newtonsoft.Json.JsonProperty("email", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    [System.ComponentModel.DataAnnotations.StringLength(255)]
    public string Email { get; set; }

    [Newtonsoft.Json.JsonProperty("realname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Realname { get; set; }

    [Newtonsoft.Json.JsonProperty("comment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Comment { get; set; }

    [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Password { get; set; }

    [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    [System.ComponentModel.DataAnnotations.StringLength(255)]
    public string Username { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class OIDCUserInfo
{
    /// <summary>
    /// the ID of the OIDC info record
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Id { get; set; }

    /// <summary>
    /// the ID of the user
    /// </summary>
    [Newtonsoft.Json.JsonProperty("user_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? User_id { get; set; }

    /// <summary>
    /// the concatenation of sub and issuer in the ID token
    /// </summary>
    [Newtonsoft.Json.JsonProperty("subiss", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Subiss { get; set; }

    /// <summary>
    /// the secret of the OIDC user that can be used for CLI to push/pull artifacts
    /// </summary>
    [Newtonsoft.Json.JsonProperty("secret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Secret { get; set; }

    /// <summary>
    /// The creation time of the OIDC user info record.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("creation_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Creation_time { get; set; }

    /// <summary>
    /// The update time of the OIDC user info record.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("update_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Update_time { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class UserResp
{
    [Newtonsoft.Json.JsonProperty("email", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Email { get; set; }

    [Newtonsoft.Json.JsonProperty("realname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Realname { get; set; }

    [Newtonsoft.Json.JsonProperty("comment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Comment { get; set; }

    [Newtonsoft.Json.JsonProperty("user_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? User_id { get; set; }

    [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Username { get; set; }

    [Newtonsoft.Json.JsonProperty("sysadmin_flag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Sysadmin_flag { get; set; }

    /// <summary>
    /// indicate the admin privilege is grant by authenticator (LDAP), is always false unless it is the current login user
    /// </summary>
    [Newtonsoft.Json.JsonProperty("admin_role_in_auth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Admin_role_in_auth { get; set; }

    [Newtonsoft.Json.JsonProperty("oidc_user_meta", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public OIDCUserInfo Oidc_user_meta { get; set; }

    /// <summary>
    /// The creation time of the user.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("creation_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Creation_time { get; set; }

    /// <summary>
    /// The update time of the user.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("update_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Update_time { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class UserSysAdminFlag
{
    /// <summary>
    /// true-admin, false-not admin.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("sysadmin_flag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Sysadmin_flag { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class UserSearch
{
    /// <summary>
    /// The ID of the user.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("user_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? User_id { get; set; }

    [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Username { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class PasswordReq
{
    /// <summary>
    /// The user's existing password.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("old_password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Old_password { get; set; }

    /// <summary>
    /// New password for marking as to be updated.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("new_password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string New_password { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class UserSearchRespItem
{
    /// <summary>
    /// The ID of the user.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("user_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? User_id { get; set; }

    [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Username { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Permission
{
    /// <summary>
    /// The permission resoruce
    /// </summary>
    [Newtonsoft.Json.JsonProperty("resource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Resource { get; set; }

    /// <summary>
    /// The permission action
    /// </summary>
    [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Action { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class OIDCCliSecretReq
{
    /// <summary>
    /// The new secret
    /// </summary>
    [Newtonsoft.Json.JsonProperty("secret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Secret { get; set; }

}

/// <summary>
/// The system health status
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class OverallHealthStatus
{
    /// <summary>
    /// The overall health status. It is "healthy" only when all the components' status are "healthy"
    /// </summary>
    [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Status { get; set; }

    [Newtonsoft.Json.JsonProperty("components", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<ComponentHealthStatus> Components { get; set; }

}

/// <summary>
/// The health status of component
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ComponentHealthStatus
{
    /// <summary>
    /// The component name
    /// </summary>
    [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Name { get; set; }

    /// <summary>
    /// The health status of component
    /// </summary>
    [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Status { get; set; }

    /// <summary>
    /// (optional) The error message when the status is "unhealthy"
    /// </summary>
    [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Error { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Statistic
{
    /// <summary>
    /// The count of the private projects
    /// </summary>
    [Newtonsoft.Json.JsonProperty("private_project_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Private_project_count { get; set; }

    /// <summary>
    /// The count of the private repositories
    /// </summary>
    [Newtonsoft.Json.JsonProperty("private_repo_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Private_repo_count { get; set; }

    /// <summary>
    /// The count of the public projects
    /// </summary>
    [Newtonsoft.Json.JsonProperty("public_project_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Public_project_count { get; set; }

    /// <summary>
    /// The count of the public repositories
    /// </summary>
    [Newtonsoft.Json.JsonProperty("public_repo_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Public_repo_count { get; set; }

    /// <summary>
    /// The count of the total projects, only be seen by the system admin
    /// </summary>
    [Newtonsoft.Json.JsonProperty("total_project_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Total_project_count { get; set; }

    /// <summary>
    /// The count of the total repositories, only be seen by the system admin
    /// </summary>
    [Newtonsoft.Json.JsonProperty("total_repo_count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Total_repo_count { get; set; }

    /// <summary>
    /// The total storage consumption of blobs, only be seen by the system admin
    /// </summary>
    [Newtonsoft.Json.JsonProperty("total_storage_consumption", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Total_storage_consumption { get; set; }

}

/// <summary>
/// The accessory of the artifact
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Accessory
{
    /// <summary>
    /// The ID of the accessory
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Id { get; set; }

    /// <summary>
    /// The artifact id of the accessory
    /// </summary>
    [Newtonsoft.Json.JsonProperty("artifact_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Artifact_id { get; set; }

    /// <summary>
    /// The subject artifact id of the accessory
    /// </summary>
    [Newtonsoft.Json.JsonProperty("subject_artifact_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Subject_artifact_id { get; set; }

    /// <summary>
    /// The artifact size of the accessory
    /// </summary>
    [Newtonsoft.Json.JsonProperty("size", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Size { get; set; }

    /// <summary>
    /// The artifact digest of the accessory
    /// </summary>
    [Newtonsoft.Json.JsonProperty("digest", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Digest { get; set; }

    /// <summary>
    /// The artifact size of the accessory
    /// </summary>
    [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Type { get; set; }

    /// <summary>
    /// The icon of the accessory
    /// </summary>
    [Newtonsoft.Json.JsonProperty("icon", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Icon { get; set; }

    /// <summary>
    /// The creation time of the accessory
    /// </summary>
    [Newtonsoft.Json.JsonProperty("creation_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Creation_time { get; set; }

}

/// <summary>
/// The criteria to select the scan data to export.
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ScanDataExportRequest
{
    /// <summary>
    /// Name of the scan data export job
    /// </summary>
    [Newtonsoft.Json.JsonProperty("job_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Job_name { get; set; }

    /// <summary>
    /// A list of one or more projects for which to export the scan data, defaults to all if empty
    /// </summary>
    [Newtonsoft.Json.JsonProperty("projects", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<long> Projects { get; set; }

    /// <summary>
    /// A list of one or more labels for which to export the scan data, defaults to all if empty
    /// </summary>
    [Newtonsoft.Json.JsonProperty("labels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<long> Labels { get; set; }

    /// <summary>
    /// A list of repositories for which to export the scan data, defaults to all if empty
    /// </summary>
    [Newtonsoft.Json.JsonProperty("repositories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Repositories { get; set; }

    /// <summary>
    /// CVE-IDs for which to export data. Multiple CVE-IDs can be specified by separating using ',' and enclosed between '{}'. Defaults to all if empty
    /// </summary>
    [Newtonsoft.Json.JsonProperty("cveIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string CveIds { get; set; }

    /// <summary>
    /// A list of tags enclosed within '{}'. Defaults to all if empty
    /// </summary>
    [Newtonsoft.Json.JsonProperty("tags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Tags { get; set; }

}

/// <summary>
/// The metadata associated with the scan data export job
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ScanDataExportJob
{
    /// <summary>
    /// The id of the scan data export job
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public long? Id { get; set; }

}

/// <summary>
/// The replication execution
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ScanDataExportExecution
{
    /// <summary>
    /// The ID of the execution
    /// </summary>
    [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Id { get; set; }

    /// <summary>
    /// The ID if the user triggering the export job
    /// </summary>
    [Newtonsoft.Json.JsonProperty("user_id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? User_id { get; set; }

    /// <summary>
    /// The status of the execution
    /// </summary>
    [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Status { get; set; }

    /// <summary>
    /// The trigger mode
    /// </summary>
    [Newtonsoft.Json.JsonProperty("trigger", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Trigger { get; set; }

    /// <summary>
    /// The start time
    /// </summary>
    [Newtonsoft.Json.JsonProperty("start_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? Start_time { get; set; }

    /// <summary>
    /// The end time
    /// </summary>
    [Newtonsoft.Json.JsonProperty("end_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.DateTimeOffset? End_time { get; set; }

    /// <summary>
    /// The status text
    /// </summary>
    [Newtonsoft.Json.JsonProperty("status_text", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Status_text { get; set; }

    /// <summary>
    /// The name of the user triggering the job
    /// </summary>
    [Newtonsoft.Json.JsonProperty("user_name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string User_name { get; set; }

    /// <summary>
    /// Indicates whether the export artifact is present in registry
    /// </summary>
    [Newtonsoft.Json.JsonProperty("file_present", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? File_present { get; set; }

}

/// <summary>
/// The list of scan data export executions
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class ScanDataExportExecutionList
{
    /// <summary>
    /// The list of scan data export executions
    /// </summary>
    [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public System.Collections.Generic.List<ScanDataExportExecution> Items { get; set; }

}

/// <summary>
/// The type of addition.
/// </summary>
[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public enum Addition
{

    [System.Runtime.Serialization.EnumMember(Value = @"build_history")]
    Build_history = 0,

    [System.Runtime.Serialization.EnumMember(Value = @"values.yaml")]
    Values_yaml = 1,

    [System.Runtime.Serialization.EnumMember(Value = @"readme.md")]
    Readme_md = 2,

    [System.Runtime.Serialization.EnumMember(Value = @"dependencies")]
    Dependencies = 3,

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Endpoint
{
    /// <summary>
    /// The URL of OIDC endpoint to be tested.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Url { get; set; }

    /// <summary>
    /// Whether the certificate should be verified
    /// </summary>
    [Newtonsoft.Json.JsonProperty("verify_cert", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Verify_cert { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Body
{
    [Newtonsoft.Json.JsonProperty("dry_run", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public bool? Dry_run { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Body2
{
    [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Action { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public enum ScheduleObjType
{

    [System.Runtime.Serialization.EnumMember(Value = @"Hourly")]
    Hourly = 0,

    [System.Runtime.Serialization.EnumMember(Value = @"Daily")]
    Daily = 1,

    [System.Runtime.Serialization.EnumMember(Value = @"Weekly")]
    Weekly = 2,

    [System.Runtime.Serialization.EnumMember(Value = @"Custom")]
    Custom = 3,

    [System.Runtime.Serialization.EnumMember(Value = @"Manual")]
    Manual = 4,

    [System.Runtime.Serialization.EnumMember(Value = @"None")]
    None = 5,

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public enum StatsTrigger
{

    [System.Runtime.Serialization.EnumMember(Value = @"Manual")]
    Manual = 0,

    [System.Runtime.Serialization.EnumMember(Value = @"Schedule")]
    Schedule = 1,

    [System.Runtime.Serialization.EnumMember(Value = @"Event")]
    Event = 2,

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Scan_all_policy
{
    /// <summary>
    /// The type of scan all policy, currently the valid values are "none" and "daily"
    /// </summary>
    [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public string Type { get; set; }

    /// <summary>
    /// The parameters of the policy, the values are dependent on the type of the policy.
    /// </summary>
    [Newtonsoft.Json.JsonProperty("parameter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public Parameter Parameter { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class Parameter
{
    /// <summary>
    /// The offset in seconds of UTC 0 o'clock, only valid when the policy type is "daily"
    /// </summary>
    [Newtonsoft.Json.JsonProperty("daily_time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
    public int? Daily_time { get; set; }

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
public partial class FileResponse : System.IDisposable
{
    private System.IDisposable _client;
    private System.IDisposable _response;

    public int StatusCode { get; private set; }

    public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

    public System.IO.Stream Stream { get; private set; }

    public bool IsPartial
    {
        get { return StatusCode == 206; }
    }

    public FileResponse(int statusCode, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.IO.Stream stream, System.IDisposable client, System.IDisposable response)
    {
        StatusCode = statusCode;
        Headers = headers;
        Stream = stream;
        _client = client;
        _response = response;
    }

    public void Dispose()
    {
        Stream.Dispose();
        if (_response != null)
            _response.Dispose();
        if (_client != null)
            _client.Dispose();
    }
}



}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore  472
#pragma warning restore  114
#pragma warning restore  108
#pragma warning restore 3016
#pragma warning restore 8603